!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r(require("@babylonjs/core/Misc/decorators"),require("@babylonjs/core/Materials/materialHelper"),require("@babylonjs/core/Materials/effect"),require("@babylonjs/core/Meshes/buffer"),require("@babylonjs/core/Materials/material"),require("@babylonjs/core/Maths/math"),require("@babylonjs/core/scene"),require("@babylonjs/core/Materials/materialDefines"),require("@babylonjs/core/Engines/constants"),require("@babylonjs/core/sceneComponent"),require("@babylonjs/core/Materials/pushMaterial"),require("@babylonjs/core/Rendering/edgesRenderer"),require("@babylonjs/core/Rendering/outlineRenderer")):"function"==typeof define&&define.amd?define(["@babylonjs/core/Misc/decorators","@babylonjs/core/Materials/materialHelper","@babylonjs/core/Materials/effect","@babylonjs/core/Meshes/buffer","@babylonjs/core/Materials/material","@babylonjs/core/Maths/math","@babylonjs/core/scene","@babylonjs/core/Materials/materialDefines","@babylonjs/core/Engines/constants","@babylonjs/core/sceneComponent","@babylonjs/core/Materials/pushMaterial","@babylonjs/core/Rendering/edgesRenderer","@babylonjs/core/Rendering/outlineRenderer"],r):"object"==typeof exports?exports["babylon-mtoon-material"]=r(require("@babylonjs/core/Misc/decorators"),require("@babylonjs/core/Materials/materialHelper"),require("@babylonjs/core/Materials/effect"),require("@babylonjs/core/Meshes/buffer"),require("@babylonjs/core/Materials/material"),require("@babylonjs/core/Maths/math"),require("@babylonjs/core/scene"),require("@babylonjs/core/Materials/materialDefines"),require("@babylonjs/core/Engines/constants"),require("@babylonjs/core/sceneComponent"),require("@babylonjs/core/Materials/pushMaterial"),require("@babylonjs/core/Rendering/edgesRenderer"),require("@babylonjs/core/Rendering/outlineRenderer")):e["babylon-mtoon-material"]=r(e["@babylonjs/core/Misc/decorators"],e["@babylonjs/core/Materials/materialHelper"],e["@babylonjs/core/Materials/effect"],e["@babylonjs/core/Meshes/buffer"],e["@babylonjs/core/Materials/material"],e["@babylonjs/core/Maths/math"],e["@babylonjs/core/scene"],e["@babylonjs/core/Materials/materialDefines"],e["@babylonjs/core/Engines/constants"],e["@babylonjs/core/sceneComponent"],e["@babylonjs/core/Materials/pushMaterial"],e["@babylonjs/core/Rendering/edgesRenderer"],e["@babylonjs/core/Rendering/outlineRenderer"])}(window,function(e,r,n,i,t,o,a,s,l,d,f,u,h){return function(e){var r={};function n(i){if(r[i])return r[i].exports;var t=r[i]={i:i,l:!1,exports:{}};return e[i].call(t.exports,t,t.exports,n),t.l=!0,t.exports}return n.m=e,n.c=r,n.d=function(e,r,i){n.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:i})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,r){if(1&r&&(e=n(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var t in e)n.d(i,t,function(r){return e[r]}.bind(null,t));return i},n.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(r,"a",r),r},n.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},n.p="",n(n.s=21)}([function(r,n){r.exports=e},function(e,n){e.exports=r},function(e,r){e.exports=n},function(e,r){e.exports=i},function(e,r){e.exports=t},function(e,r){e.exports=o},function(e,r){e.exports=a},function(e,r){e.exports=s},function(e,r){e.exports=l},function(e,r){e.exports=d},function(e,r){e.exports=f},function(e,r,n){"use strict";n.r(r),r.default="uniform mat4 viewProjection;\r\n\r\n// Attribute\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n\r\n#include<helperFunctions>\r\n\r\n#include<bonesDeclaration>\r\n\r\n#include<instancesDeclaration>\r\n\r\n#include<fogVertexDeclaration>\r\n\r\n#include<morphTargetsVertexGlobalDeclaration>\r\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\r\n\r\n// Uniform\r\nuniform vec2 vOutlineWidthInfos;\r\nuniform mat4 outlineWidthMatrix;\r\nuniform sampler2D outlineWidthSampler;\r\nuniform float outlineWidth;\r\nuniform float outlineScaledMaxDistance;\r\nuniform float aspect;\r\n\r\nvoid main(void)\r\n{\r\n    // Texture coordinates\r\n#ifndef UV1\r\n    vec2 uv = vec2(0., 0.);\r\n#endif\r\n#ifndef UV2\r\n    vec2 uv2 = vec2(0., 0.);\r\n#endif\r\n\r\n    vec3 positionUpdated = position;\r\n    vec3 normalUpdated = normal;\r\n\r\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\r\n\r\n#include<instancesVertex>\r\n#include<bonesVertex>\r\n\r\n    float outlineTex = 1.0;\r\n    vec2 texUV = uv;\r\n#if defined(OUTLINE_WIDTH) && OUTLINE_WIDTHDIRECTUV == 0\r\n    if (vOutlineWidthInfos.x == 0.)\r\n    {\r\n        texUV = vec2(outlineWidthMatrix * vec4(uv, 1.0, 0.0));\r\n    }\r\n    else\r\n    {\r\n        texUV = vec2(outlineWidthMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#ifdef OUTLINE_WIDTH\r\n    outlineTex = texture2D(outlineWidthSampler, texUV).r * vOutlineWidthInfos.y;\r\n#endif\r\n\r\n#ifdef MTOON_OUTLINE_WIDTH_WORLD\r\n    // ワールド座標の normal 分だけ移動する\r\n    vec3 outlineOffset = normalize(finalWorld * vec4(normalUpdated, 1.0)).xyz * 0.01 * outlineWidth * outlineTex;\r\n    positionUpdated.xyz += outlineOffset;\r\n#endif\r\n\r\n    vec4 vertex = vec4(1.0);\r\n#ifdef MULTIVIEW\r\n    if (gl_ViewID_OVR == 0u) {\r\n        vertex = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\r\n    } else {\r\n        vertex = viewProjectionR * finalWorld * vec4(positionUpdated, 1.0);\r\n    }\r\n#else\r\n    vertex = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\r\n#endif\r\n\r\n#ifdef MTOON_OUTLINE_WIDTH_SCREEN\r\n    vec4 projectedNormal = normalize(viewProjection * finalWorld * vec4(normalUpdated, 1.0));\r\n    projectedNormal *= min(vertex.w, outlineScaledMaxDistance);\r\n    projectedNormal.x *= aspect;\r\n    vertex.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\r\n#endif\r\n\r\n    // for fogVertex\r\n    vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\r\n\r\n#include<fogVertex>\r\n\r\n    gl_Position = vertex;\r\n}\r\n"},function(e,r,n){"use strict";n.r(r),r.default="uniform vec3 vOutlineColor;\r\n\r\n#include<fogFragmentDeclaration>\r\n\r\nvoid main(void) {\r\n    vec4 color = vec4(vOutlineColor, 1.0);\r\n\r\n#include<fogFragment>\r\n\r\n    gl_FragColor = color;\r\n}\r\n"},function(e,r){e.exports=u},function(e,r){e.exports=h},function(e,r,n){"use strict";n.r(r),r.default="// include<__decl__mtoonVertex> または include<__decl__mtoonFragment> と書いた時に展開される\r\n// @see effect.ts\r\n\r\nlayout(std140, column_major) uniform;\r\n\r\nuniform Material\r\n{\r\n    vec4 vDiffuseColor;\r\n    vec2 vDiffuseInfos;\r\n    mat4 diffuseMatrix;\r\n    vec4 vEmissiveColor;\r\n    vec2 vEmissiveInfos;\r\n    mat4 emissiveMatrix;\r\n    vec3 vBumpInfos;\r\n    mat4 bumpMatrix;\r\n    vec3 vShadeColor;\r\n    vec2 vShadeInfos;\r\n    mat4 shadeMatrix;\r\n    vec2 vReceiveShadowInfos;\r\n    mat4 receiveShadowMatrix;\r\n    vec2 vShadingGradeInfos;\r\n    mat4 shadingGradeMatrix;\r\n    vec2 vMatCapInfos;\r\n    mat4 matCapMatrix;\r\n    vec4 vOutlineColor;\r\n    vec2 vOutlineWidthInfos;\r\n    mat4 outlineWidthMatrix;\r\n    vec2 vTangentSpaceParams;\r\n    float pointSize;\r\n    float visibility;\r\n    float shadingGradeRate;\r\n    float receiveShadowRate;\r\n    float shadeShift;\r\n    float shadeToony;\r\n    float lightColorAttenuation;\r\n    float indirectLightIntensity;\r\n    float outlineWidth;\r\n    float outlineScaledMaxDistance;\r\n    float outlineLightingMix;\r\n};\r\n\r\nuniform Scene {\r\n    mat4 viewProjection;\r\n#ifdef MULTIVIEW\r\n    mat4 viewProjectionR;\r\n#endif\r\n    mat4 view;\r\n};\r\n"},function(e,r,n){"use strict";n.r(r),r.default="// Uniforms\r\nuniform mat4 viewProjection;\r\nuniform mat4 view;\r\n\r\n#ifdef DIFFUSE\r\nuniform mat4 diffuseMatrix;\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nuniform vec2 vEmissiveInfos;\r\nuniform mat4 emissiveMatrix;\r\n#endif\r\n\r\n#ifdef BUMP\r\nuniform vec3 vBumpInfos;\r\nuniform mat4 bumpMatrix;\r\n#endif\r\n\r\n#ifdef SHADE\r\nuniform vec2 vShadeInfos;\r\nuniform mat4 shadeMatrix;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOW\r\nuniform vec2 vReceiveShadowInfos;\r\nuniform mat4 receiveShadowMatrix;\r\n#endif\r\n\r\n#ifdef SHADING_GRADE\r\nuniform vec2 vShadingGradeInfos;\r\nuniform mat4 shadingGradeMatrix;\r\n#endif\r\n\r\n#ifdef MATCAP\r\nuniform vec2 vMatCapInfos;\r\nuniform mat4 matCapMatrix;\r\n#endif\r\n\r\n#ifdef OUTLINE_WIDTH\r\nuniform vec2 vOutlineWidthInfos;\r\nuniform mat4 outlineWidthMatrix;\r\n#endif\r\n\r\n#ifdef POINTSIZE\r\nuniform float pointSize;\r\n#endif\r\n"},function(e,r,n){"use strict";n.r(r),r.default="uniform mat4 viewProjection;\r\nuniform mat4 view;\r\nuniform vec4 vDiffuseColor;\r\nuniform vec3 vEmissiveColor;\r\nuniform vec3 vShadeColor;\r\nuniform vec3 vOutlineColor;\r\n\r\nuniform float visibility;\r\n\r\n// Samplers\r\n#ifdef DIFFUSE\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nuniform vec2 vEmissiveInfos;\r\n#endif\r\n\r\n#ifdef BUMP\r\nuniform vec3 vBumpInfos;\r\nuniform vec2 vTangentSpaceParams;\r\n#endif\r\n\r\n#ifdef SHADE\r\nuniform vec2 vShadeInfos;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOW\r\nuniform vec2 vReceiveShadowInfos;\r\n#endif\r\n\r\n#ifdef SHADING_GRADE\r\nuniform vec2 vShadingGradeInfos;\r\n#endif\r\n\r\n#ifdef MATCAP\r\nuniform vec2 vMatCapInfos;\r\n#endif\r\n\r\n#ifdef OUTLINE_WIDTH\r\nuniform vec2 vOutlineWidthInfos;\r\n#endif\r\n\r\nuniform float shadingGradeRate;\r\nuniform float receiveShadowRate;\r\nuniform float shadeShift;\r\nuniform float shadeToony;\r\nuniform float lightColorAttenuation;\r\nuniform float indirectLightIntensity;\r\nuniform float outlineWidth;\r\nuniform float outlineScaledMaxDistance;\r\nuniform float outlineLightingMix;\r\n"},function(e,r,n){"use strict";n.r(r),r.default="#ifdef LIGHT{X}\r\n    // 影の計算は流用\r\n    #ifdef SHADOW{X}\r\n        #ifdef SHADOWCLOSEESM{X}\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWESM{X})\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWPOISSON{X})\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWPCF{X})\r\n            #if defined(SHADOWLOWQUALITY{X})\r\n                shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #elif defined(SHADOWMEDIUMQUALITY{X})\r\n                shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #else\r\n                shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWPCSS{X})\r\n            #if defined(SHADOWLOWQUALITY{X})\r\n                shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #elif defined(SHADOWMEDIUMQUALITY{X})\r\n                shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #else\r\n                shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #else\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #endif\r\n    #else\r\n        shadow = 1.;\r\n    #endif\r\n\r\n    // ここで MToon のライティングを適用\r\n    #ifdef SPOTLIGHT{X}\r\n        lightDirection = computeSpotLightDirection(light{X}.vLightData);\r\n    #elif defined(HEMILIGHT{X})\r\n        lightDirection = computeHemisphericLightDirection(light{X}.vLightData, normalW.xyz);\r\n    #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\r\n        lightDirection = computeLightDirection(light{X}.vLightData);\r\n    #endif\r\n    mtoonDiffuse = computeMToonDiffuseLighting(viewDirectionW.xyz, normalW.xyz, uvOffset, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\r\n    diffuseBase = mtoonDiffuse.rgb;\r\n    alpha = alpha * mtoonDiffuse.a;\r\n    #ifdef ALPHATEST\r\n        if (alpha < alphaCutOff) {\r\n            discard;\r\n        }\r\n    #endif\r\n\r\n    #ifdef SPECULARTERM\r\n        specularBase += info.specular * shadow;\r\n    #endif\r\n    #ifdef CLEARCOAT\r\n        clearCoatBase += info.clearCoat.rgb * shadow;\r\n    #endif\r\n    #ifdef SHEEN\r\n        sheenBase += info.sheen.rgb * shadow;\r\n    #endif\r\n#endif\r\n"},function(e,r,n){"use strict";n.r(r),r.default="// この include は特別で、 UboDeclaration または VertexDeclaration のどちらかに置換される\r\n// @see effect.ts\r\n#include<__decl__mtoonVertex>\r\n\r\n// 基本的に default.vertex.fx のまま\r\n\r\n// Attributes\r\n\r\nattribute vec3 position;\r\n#ifdef NORMAL\r\nattribute vec3 normal;\r\n#endif\r\n#ifdef TANGENT\r\nattribute vec4 tangent;\r\n#endif\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n\r\n#include<helperFunctions>\r\n\r\n#include<bonesDeclaration>\r\n\r\n// Uniforms\r\n#include<instancesDeclaration>\r\n\r\n#ifdef MAINUV1\r\nvarying vec2 vMainUV1;\r\n#endif\r\n\r\n#ifdef MAINUV2\r\nvarying vec2 vMainUV2;\r\n#endif\r\n\r\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\r\nvarying vec2 vDiffuseUV;\r\n#endif\r\n\r\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\r\nvarying vec2 vEmissiveUV;\r\n#endif\r\n\r\n#if defined(BUMP) && BUMPDIRECTUV == 0\r\nvarying vec2 vBumpUV;\r\n#endif\r\n\r\n// Output\r\nvarying vec3 vPositionW;\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#include<bumpVertexDeclaration>\r\n\r\n#include<clipPlaneVertexDeclaration>\r\n\r\n#include<fogVertexDeclaration>\r\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\r\n\r\n#include<morphTargetsVertexGlobalDeclaration>\r\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\r\n\r\n#include<logDepthDeclaration>\r\n\r\n\r\n// Additional Uniforms\r\n#if defined(SHADE) && SHADEDIRECTUV == 0\r\n    varying vec2 vShadeUV;\r\n#endif\r\n#if defined(RECEIVE_SHADOW) && RECEIVE_SHADOWDIRECTUV == 0\r\n    varying vec2 vReceiveShadowUV;\r\n#endif\r\n#if defined(SHADING_GRADE) && SHADING_GRADEDIRECTUV == 0\r\n    varying vec2 vShadingGradeUV;\r\n#endif\r\n#if defined(MATCAP) && MATCAPDIRECTUV == 0\r\n    varying vec2 vMatCapUV;\r\n#endif\r\n#if defined(OUTLINE_WIDTH) && OUTLINE_WIDTHDIRECTUV == 0\r\n    varying vec2 vOutlineWidthUV;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n    vec3 positionUpdated = position;\r\n#ifdef NORMAL\r\n    vec3 normalUpdated = normal;\r\n#endif\r\n#ifdef TANGENT\r\n    vec4 tangentUpdated = tangent;\r\n#endif\r\n\r\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\r\n\r\n#include<instancesVertex>\r\n#include<bonesVertex>\r\n\r\n#ifdef MULTIVIEW\r\n    if (gl_ViewID_OVR == 0u) {\r\n        gl_Position = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\r\n    } else {\r\n        gl_Position = viewProjectionR * finalWorld * vec4(positionUpdated, 1.0);\r\n    }\r\n#else\r\n    gl_Position = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\r\n#endif\r\n\r\n    vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\r\n    vPositionW = vec3(worldPos);\r\n\r\n#ifdef NORMAL\r\n    mat3 normalWorld = mat3(finalWorld);\r\n\r\n    #ifdef NONUNIFORMSCALING\r\n        normalWorld = transposeMat3(inverseMat3(normalWorld));\r\n    #endif\r\n\r\n    vNormalW = normalize(normalWorld * normalUpdated);\r\n#endif\r\n\r\n    // Texture coordinates\r\n#ifndef UV1\r\n    vec2 uv = vec2(0., 0.);\r\n#endif\r\n#ifndef UV2\r\n    vec2 uv2 = vec2(0., 0.);\r\n#endif\r\n\r\n#ifdef MAINUV1\r\n    vMainUV1 = uv;\r\n#endif\r\n\r\n#ifdef MAINUV2\r\n    vMainUV2 = uv2;\r\n#endif\r\n\r\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\r\n    if (vDiffuseInfos.x == 0.)\r\n    {\r\n        vDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n    }\r\n    else\r\n    {\r\n        vDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\r\n    if (vEmissiveInfos.x == 0.)\r\n    {\r\n        vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\r\n    }\r\n    else\r\n    {\r\n        vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#if defined(BUMP) && BUMPDIRECTUV == 0\r\n    if (vBumpInfos.x == 0.)\r\n    {\r\n        vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\r\n    }\r\n    else\r\n    {\r\n        vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#if defined(SHADE) && SHADEDIRECTUV == 0\r\n    if (vShadeInfos.x == 0.) {\r\n        vShadeUV = vec2(shadeMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vShadeUV = vec2(shadeMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(RECEIVE_SHADOW) && RECEIVE_SHADOWDIRECTUV == 0\r\n    if (vReceiveShadowInfos.x == 0.) {\r\n        vReceiveShadowUV = vec2(receiveShadowMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vReceiveShadowUV = vec2(receiveShadowMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(SHADING_GRADE) && SHADING_GRADEDIRECTUV == 0\r\n    if (vShadingGradeInfos.x == 0.) {\r\n        vShadingGradeUV = vec2(shadingGradeMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vShadingGradeUV = vec2(shadingGradeMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(MATCAP) && MATCAPDIRECTUV == 0\r\n    if (vMatCapInfos.x == 0.) {\r\n        vMatCapUV = vec2(matCapMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vMatCapUV = vec2(matCapMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(OUTLINE_WIDTH) && OUTLINE_WIDTHDIRECTUV == 0\r\n    if (vOutlineWidthInfos.x == 0.) {\r\n        vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#include<bumpVertex>\r\n#include<clipPlaneVertex>\r\n#include<fogVertex>\r\n#include<shadowsVertex>[0..maxSimultaneousLights]\r\n\r\n#include<pointCloudVertex>\r\n#include<logDepthVertex>\r\n\r\n}\r\n"},function(e,r,n){"use strict";n.r(r),r.default="#include<__decl__mtoonFragment>\r\n\r\n#if defined(BUMP) || !defined(NORMAL)\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\n#ifdef LOGARITHMICDEPTH\r\n#extension GL_EXT_frag_depth : enable\r\n#endif\r\n\r\n// Constants\r\n#define RECIPROCAL_PI2 0.15915494\r\n\r\nuniform vec3 vEyePosition;\r\nuniform vec3 vEyeUp;\r\nuniform vec3 vAmbientColor;\r\n\r\n// Input\r\nvarying vec3 vPositionW;\r\n\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#ifdef MAINUV1\r\n    varying vec2 vMainUV1;\r\n#endif\r\n\r\n#ifdef MAINUV2\r\n    varying vec2 vMainUV2;\r\n#endif\r\n\r\n// Helper functions\r\n#include<helperFunctions>\r\n\r\n// Lights\r\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\r\n\r\n#include<lightsFragmentFunctions>\r\n#include<shadowsFragmentFunctions>\r\n\r\n// Samplers\r\n#ifdef DIFFUSE\r\n    #if DIFFUSEDIRECTUV == 1\r\n        #define vDiffuseUV vMainUV1\r\n    #elif DIFFUSEDIRECTUV == 2\r\n        #define vDiffuseUV vMainUV2\r\n    #else\r\n        varying vec2 vDiffuseUV;\r\n    #endif\r\n    uniform sampler2D diffuseSampler;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\n    #if EMISSIVEDIRECTUV == 1\r\n        #define vEmissiveUV vMainUV1\r\n    #elif EMISSIVEDIRECTUV == 2\r\n        #define vEmissiveUV vMainUV2\r\n    #else\r\n        varying vec2 vEmissiveUV;\r\n    #endif\r\n    uniform sampler2D emissiveSampler;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n     uniform float alphaCutOff;\r\n#endif\r\n\r\n#ifdef SHADE\r\n    uniform sampler2D shadeSampler;\r\n    #if SHADEDIRECTUV == 1\r\n        #define vShadeUV vMainUV1\r\n    #elif SHADEDIRECTUV == 2\r\n        #define vShadeUV vMainUV2\r\n    #else\r\n        varying vec2 vShadeUV;\r\n    #endif\r\n#endif\r\n#ifdef RECEIVE_SHADOW\r\n    uniform sampler2D receiveShadowSampler;\r\n    #if RECEIVE_SHADOWDIRECTUV == 1\r\n        #define vReceiveShadowUV vMainUV1\r\n    #elif RECEIVE_SHADOWDIRECTUV == 2\r\n        #define vReceiveShadowUV vMainUV2\r\n    #else\r\n        varying vec2 vReceiveShadowUV;\r\n    #endif\r\n#endif\r\n#ifdef SHADING_GRADE\r\n    uniform sampler2D shadingGradeSampler;\r\n    #if SHADING_GRADEDIRECTUV == 1\r\n        #define vShadingGradeUV vMainUV1\r\n    #elif SHADING_GRADEDIRECTUV == 2\r\n        #define vShadingGradeUV vMainUV2\r\n    #else\r\n        varying vec2 vShadingGradeUV;\r\n    #endif\r\n#endif\r\n#ifdef MATCAP\r\n    uniform sampler2D matCapSampler;\r\n    #if MATCAPDIRECTUV == 1\r\n        #define vMatCapUV vMainUV1\r\n    #elif MATCAPDIRECTUV == 2\r\n        #define vMatCapUV vMainUV2\r\n    #else\r\n        varying vec2 vMatCapUV;\r\n    #endif\r\n#endif\r\n#ifdef OUTLINE_WIDTH\r\n    uniform sampler2D outlineWidthSampler;\r\n    #if OUTLINE_WIDTHDIRECTUV == 1\r\n        #define vOutlineWidthUV vMainUV1\r\n    #elif OUTLINE_WIDTHDIRECTUV == 2\r\n        #define vOutlineWidthUV vMainUV2\r\n    #else\r\n        varying vec2 vOutlineWidthUV;\r\n    #endif\r\n#endif\r\n\r\n/**\r\n* DirectionLight, PointLight の角度を計算\r\n*/\r\nvec3 computeLightDirection(vec4 lightData) {\r\n      return normalize(mix(lightData.xyz - vPositionW, -lightData.xyz, lightData.w));\r\n}\r\n\r\n/**\r\n* SpotLight の角度を計算\r\n*/\r\nvec3 computeSpotLightDirection(vec4 lightData) {\r\n     return normalize(lightData.xyz - vPositionW);\r\n}\r\n\r\n/**\r\n* HemisphericLight の角度を計算\r\n*/\r\nvec3 computeHemisphericLightDirection(vec4 lightData, vec3 vNormal) {\r\n     return normalize(-lightData.xyz);\r\n}\r\n\r\n/**\r\n* MToon シェーダーの陰実装\r\n*/\r\nvec4 computeMToonDiffuseLighting(vec3 worldView, vec3 worldNormal, vec2 uvOffset, vec3 lightDirection, vec4 lightDiffuse, float shadow) {\r\n    float _receiveShadow = receiveShadowRate;\r\n#ifdef RECEIVE_SHADOW\r\n    _receiveShadow = _receiveShadow * texture2D(receiveShadowSampler, vReceiveShadowUV + uvOffset).a;\r\n#endif\r\n\r\n    float _shadingGrade = shadingGradeRate;\r\n#ifdef SHADING_GRADE\r\n    _shadingGrade = _shadingGrade * (1.0 - texture2D(shadingGradeSampler, vShadingGradeUV + uvOffset).r);\r\n#endif\r\n\r\n    // lighting intensity\r\n    float _lightIntensity = dot(lightDirection, worldNormal);\r\n    _lightIntensity = _lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]\r\n    _lightIntensity = _lightIntensity * (1.0 - _receiveShadow * (1.0 - (shadow * 0.5 + 0.5))); // receive shadow\r\n    _lightIntensity = _lightIntensity * _shadingGrade; // darker\r\n    _lightIntensity = _lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\r\n    _lightIntensity = smoothstep(shadeShift, shadeShift + (1.0 - shadeToony), _lightIntensity); // shade & tooned\r\n\r\n    // lighting with color\r\n    vec3 _directLighting = lightDiffuse.rgb; // direct\r\n    vec3 _lighting = _directLighting;\r\n    _lighting = mix(_lighting, vec3(max(0.001, max(_lighting.x, max(_lighting.y, _lighting.z)))), lightColorAttenuation);\r\n\r\n    // GI\r\n    vec3 _indirectLighting = indirectLightIntensity * vAmbientColor.rgb;\r\n    _indirectLighting = mix(_indirectLighting, vec3(max(0.001, max(_indirectLighting.x, max(_indirectLighting.y, _indirectLighting.z)))), lightColorAttenuation);\r\n\r\n    // color lerp\r\n    vec3 _shade = vShadeColor;\r\n#ifdef SHADE\r\n    _shade = _shade * texture2D(shadeSampler, vShadeUV + uvOffset).rgb;\r\n#endif\r\n\r\n    vec4 _lit = vDiffuseColor;\r\n#ifdef DIFFUSE\r\n    _lit = _lit * texture2D(diffuseSampler, vDiffuseUV + uvOffset);\r\n#endif\r\n\r\n    vec3 _result = mix(_shade.rgb, _lit.rgb, _lightIntensity);\r\n    _result = _result * _lighting + _indirectLighting * _lit.rgb;\r\n\r\n    // additive matcap\r\n#ifdef MTOON_FORWARD_ADD\r\n#else\r\n#ifdef MATCAP\r\n    vec3 _worldViewUp = normalize(vEyeUp - worldView * dot(worldView, vEyeUp));\r\n    vec3 _worldViewRight = normalize(cross(worldView, _worldViewUp));\r\n    vec2 _matCapUv = vec2(dot(_worldViewRight, worldNormal), dot(_worldViewUp, worldNormal)) * 0.5 + 0.5;\r\n    _matCapUv.y = (1.0 - _matCapUv.y);\r\n    vec3 _matCapLighting = texture2D(matCapSampler, _matCapUv + uvOffset).rgb;\r\n    _result += _matCapLighting;\r\n#endif\r\n#endif\r\n\r\n    // TODO outline\r\n\r\n    // debug\r\n#ifdef MTOON_DEBUG_NORMAL\r\n    #ifdef MTOON_FORWARD_ADD\r\n        return vec4(0.0);\r\n    #else\r\n        return vec4(worldNormal * 0.5 + 0.5, _lit.a);\r\n    #endif\r\n#elif defined(MTOON_DEBUG_LITSHADERATE)\r\n    #ifdef MTOON_FORWARD_ADD\r\n        return vec4(0.0);\r\n    #else\r\n        return vec4(_lightIntensity * _lighting, _lit.a);\r\n    #endif\r\n#endif\r\n\r\n    return vec4(_result, _lit.a);\r\n}\r\n\r\n#include<bumpFragmentFunctions>\r\n#include<clipPlaneFragmentDeclaration>\r\n#include<logDepthDeclaration>\r\n#include<fogFragmentDeclaration>\r\n\r\nvoid main(void) {\r\n#ifdef MTOON_CLIP_IF_OUTLINE_IS_NONE\r\n    #ifdef MTOON_OUTLINE_WIDTH_WORLD\r\n    #elif MTOON_OUTLINE_WIDTH_SCREEN\r\n    #else\r\n        discard;\r\n    #endif\r\n#endif\r\n\r\n#include<clipPlaneFragment>\r\n\r\n    vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\r\n\r\n    // Base color\r\n    vec4 baseColor = vec4(1., 1., 1., 1.);\r\n    vec3 diffuseColor = vDiffuseColor.rgb;\r\n\r\n\r\n#ifdef DIFFUSE\r\n    baseColor.rgb *= vDiffuseInfos.y;\r\n#endif\r\n\r\n    // Alpha\r\n    float alpha = 1.0;\r\n\r\n    // Bump\r\n#ifdef NORMAL\r\n     vec3 normalW = normalize(vNormalW);\r\n#else\r\n     vec3 normalW = normalize(-cross(dFdx(vPositionW), dFdy(vPositionW)));\r\n#endif\r\n\r\n#include<bumpFragment>\r\n\r\n#ifdef TWOSIDEDLIGHTING\r\n     normalW = gl_FrontFacing ? normalW : -normalW;\r\n#endif\r\n\r\n#include<depthPrePass>\r\n\r\n    // Ambient color\r\n    vec3 baseAmbientColor = vec3(1., 1., 1.);\r\n    float glossiness = 0.;\r\n\r\n    // Lighting\r\n    vec3 diffuseBase = vec3(0., 0., 0.);\r\n    lightingInfo info;\r\n    float shadow = 1.;\r\n    vec3 lightDirection = vec3(0.0, 1.0, 0.0);\r\n    vec4 mtoonDiffuse = vec4(0.0, 0.0, 0.0, 1.0);\r\n\r\n// 通常の lightFragment ではなく、自前実装の mtoonLightFragment を読み込む\r\n#include<mtoonLightFragment>[0..maxSimultaneousLights]\r\n\r\n    // Emissive\r\n    vec3 emissiveColor = vEmissiveColor.rgb;\r\n#ifdef EMISSIVE\r\n     emissiveColor *= texture2D(emissiveSampler, vEmissiveUV + uvOffset).rgb * vEmissiveInfos.y;\r\n#endif\r\n\r\n    vec3 finalDiffuse = clamp(diffuseBase + emissiveColor, 0.0, 1.0) * baseColor.rgb;\r\n\r\n    // Composition\r\n    vec4 color = vec4(finalDiffuse, alpha);\r\n\r\n    color.rgb = max(color.rgb, 0.);\r\n#include<logDepthFragment>\r\n#include<fogFragment>\r\n\r\n     color.a *= visibility;\r\n\r\n#ifdef PREMULTIPLYALPHA\r\n    // Convert to associative (premultiplied) format if needed.\r\n    color.rgb *= color.a;\r\n#endif\r\n\r\n     gl_FragColor = color;\r\n}\r\n"},function(e,r,n){"use strict";n.r(r);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var i=function(e,r){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,r){e.__proto__=r}||function(e,r){for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n])})(e,r)};function t(e,r){function n(){this.constructor=e}i(e,r),e.prototype=null===r?Object.create(r):(n.prototype=r.prototype,new n)}function o(e,r,n,i){var t,o=arguments.length,a=o<3?r:null===i?i=Object.getOwnPropertyDescriptor(r,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,r,n,i);else for(var s=e.length-1;s>=0;s--)(t=e[s])&&(a=(o<3?t(a):o>3?t(r,n,a):t(r,n))||a);return o>3&&a&&Object.defineProperty(r,n,a),a}var a,s,l,d,f=n(8),u=n(2),h=n(4),c=n(1),p=n(10),m=n(5),v=n(3),g=n(0),M=n(6),_=n(7),T=function(e){function r(){var r=e.call(this)||this;return r.MTOON_OUTLINE_WIDTH_WORLD=!1,r.MTOON_OUTLINE_WIDTH_SCREEN=!1,r.MTOON_OUTLINE_COLOR_FIXED=!1,r.MTOON_OUTLINE_COLOR_MIXED=!1,r.MTOON_DEBUG_NORMAL=!1,r.MTOON_DEBUG_LITSHADERRATE=!1,r.NORMAL=!1,r.TANGENT=!1,r.UV1=!1,r.UV2=!1,r.VERTEXALPHA=!1,r.MAINUV1=!1,r.MAINUV2=!1,r.DIFFUSE=!1,r.DIFFUSEDIRECTUV=0,r.EMISSIVE=!1,r.EMISSIVEDIRECTUV=0,r.BUMP=!1,r.BUMPDIRECTUV=0,r.SHADE=!1,r.SHADEDIRECTUV=0,r.RECEIVE_SHADOW=!1,r.RECEIVE_SHADOWDIRECTUV=0,r.SHADING_GRADE=!1,r.SHADING_GRADEDIRECTUV=0,r.MATCAP=!1,r.MATCAPDIRECTUV=0,r.OUTLINE_WIDTH=!1,r.OUTLINE_WIDTHDIRECTUV=0,r.MULTIVIEW=!1,r.FOG=!1,r.POINTSIZE=!1,r.LOGARITHMICDEPTH=!1,r.NONUNIFORMSCALING=!1,r.ALPHATEST=!1,r.DEPTHPREPASS=!1,r.NUM_MORPH_INFLUENCERS=0,r.NUM_BONE_INFLUENCERS=0,r.BonesPerMesh=0,r.TWOSIDEDLIGHTING=!1,r.CLIPPLANE=!1,r.CLIPPLANE2=!1,r.CLIPPLANE3=!1,r.CLIPPLANE4=!1,r.BONETEXTURE=!1,r.INSTANCES=!1,r.SHADOWFLOAT=!1,r.MORPHTARGETS=!1,r.MORPHTARGETS_NORMAL=!1,r.MORPHTARGETS_TANGENT=!1,r.PREMULTIPLYALPHA=!1,r.rebuild(),r}return t(r,e),r}(_.MaterialDefines),I=n(9),S=function(e){function r(){var r=e.call(this)||this;return r.MTOON_OUTLINE_WIDTH_WORLD=!1,r.MTOON_OUTLINE_WIDTH_SCREEN=!1,r.MTOON_OUTLINE_COLOR_FIXED=!1,r.MTOON_OUTLINE_COLOR_MIXED=!1,r.OUTLINE_WIDTH=!1,r.OUTLINE_WIDTHDIRECTUV=0,r.NORMAL=!0,r.UV1=!1,r.UV2=!1,r.MAINUV1=!1,r.MAINUV2=!1,r.NUM_BONE_INFLUENCERS=0,r.BONETEXTURE=!1,r.INSTANCES=!1,r.NUM_MORPH_INFLUENCERS=0,r.MORPHTARGETS=!1,r.MORPHTARGETS_NORMAL=!1,r.MORPHTARGETS_TANGENT=!1,r.MULTIVIEW=!1,r.NONUNIFORMSCALING=!1,r.rebuild(),r}return t(r,e),r}(_.MaterialDefines),E=n(11).default,O=n(12).default,D="MToonOutline",b=function(){function e(e,r){this.scene=e,this.material=r,this._savedDepthWrite=!1,this.name=D+"_"+r.name,this.scene._addComponent(this),this._engine=this.scene.getEngine(),u.Effect.ShadersStore.mtoonOutlineVertexShader||(u.Effect.ShadersStore.mtoonOutlineVertexShader=E,u.Effect.ShadersStore.mtoonOutlineFragmentShader=O)}return e.prototype.register=function(){this.scene._beforeRenderingMeshStage.registerStep(I.SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE,this,this._beforeRenderingMesh),this.scene._afterRenderingMeshStage.registerStep(I.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)},e.prototype.rebuild=function(){},e.prototype.dispose=function(){delete this.scene,delete this.material,delete this._engine},e.prototype.render=function(e,r,n){if(this.isReady(e,r,n)){var i=this._effect;this.material.applyOutlineCullMode(),this._engine.enableEffect(i),this.bind(e),e._bind(r,i,h.Material.TriangleFillMode),this._engine.setZOffset(-1),e._processRendering(r,i,h.Material.TriangleFillMode,n,this.isHardwareInstancedRendering(r._id,n),function(e,r,n){i.setMatrix("world",r)}),this._engine.setZOffset(0),this.material.restoreOutlineCullMode()}},e.prototype.isReady=function(e,r,n){if(!this.scene.activeCamera)return!1;if(this._defines||(this._defines=new S),this._effect&&this._defines._renderId===this.scene.getRenderId())return!0;var i=this.scene,t=this._defines;if(t._needNormals=!0,0!==this.material.outlineColorMode||t.MTOON_OUTLINE_COLOR_FIXED?1!==this.material.outlineColorMode||t.MTOON_OUTLINE_COLOR_MIXED||(t.MTOON_OUTLINE_COLOR_MIXED=!0,t.MTOON_OUTLINE_COLOR_FIXED=!1,t.markAsMiscDirty()):(t.MTOON_OUTLINE_COLOR_MIXED=!1,t.MTOON_OUTLINE_COLOR_FIXED=!0,t.markAsMiscDirty()),0===this.material.outlineWidthMode&&(t.MTOON_OUTLINE_WIDTH_SCREEN||t.MTOON_OUTLINE_WIDTH_WORLD))return t.MTOON_OUTLINE_WIDTH_SCREEN=!1,t.MTOON_OUTLINE_WIDTH_WORLD=!1,t.markAsMiscDirty(),!1;if(1!==this.material.outlineWidthMode||t.MTOON_OUTLINE_WIDTH_WORLD?2!==this.material.outlineWidthMode||t.MTOON_OUTLINE_WIDTH_SCREEN||(t.MTOON_OUTLINE_WIDTH_SCREEN=!0,t.MTOON_OUTLINE_WIDTH_WORLD=!1,t.markAsMiscDirty()):(t.MTOON_OUTLINE_WIDTH_SCREEN=!1,t.MTOON_OUTLINE_WIDTH_WORLD=!0,t.markAsMiscDirty()),c.MaterialHelper.PrepareDefinesForMultiview(i,t),t._areTexturesDirty)if(t._needUVs=!1,t.MAINUV1=!1,t.MAINUV2=!1,i.texturesEnabled)if(this.material.outlineWidthTexture){if(!this.material.outlineWidthTexture.isReadyOrNotBlocking())return!1;c.MaterialHelper.PrepareDefinesForMergedUV(this.material.outlineWidthTexture,t,"OUTLINE_WIDTH")}else t.OUTLINE_WIDTH=!1;else t.OUTLINE_WIDTH=!1;if(c.MaterialHelper.PrepareDefinesForMisc(e,i,!1,!1,!0,!1,t),c.MaterialHelper.PrepareDefinesForAttributes(e,t,!1,!0,!0,!1),c.MaterialHelper.PrepareDefinesForFrameBoundValues(i,this._engine,t,this.isHardwareInstancedRendering(r._id,n)),t.isDirty||!this._effect){t.markAsProcessed();var o=new u.EffectFallbacks;t.MULTIVIEW&&o.addFallback(0,"MULTIVIEW");var a=[v.VertexBuffer.PositionKind];a.push(v.VertexBuffer.NormalKind),t.UV1&&a.push(v.VertexBuffer.UVKind),t.UV2&&a.push(v.VertexBuffer.UV2Kind),c.MaterialHelper.PrepareAttributesForBones(a,e,t,o),c.MaterialHelper.PrepareAttributesForInstances(a,t),c.MaterialHelper.PrepareAttributesForMorphTargets(a,e,t),this._effect=this._engine.createEffect("mtoonOutline",{attributes:a,defines:t.toString(),fallbacks:o,uniformsNames:["world","view","viewProjection","vFogInfos","vFogColor","mBones","boneTextureWidth","morphTargetInfluences","vOutlineWidthInfos","outlineWidthMatrix","vOutlineColor","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","aspect"],uniformBuffersNames:[],samplers:["outlineWidthSampler","boneSampler"],maxSimultaneousLights:0,indexParameters:{maxSimultaneousLights:0,maxSimultaneousMorphTargets:t.NUM_MORPH_INFLUENCERS},onCompiled:null,onError:function(e,r){console.error("MToonOutlineRenderer Compile Error",r)},transformFeedbackVaryings:null},this._engine)}return this._effect.isReady()},e.prototype.bind=function(e){if(this._defines&&this._effect){if(c.MaterialHelper.BindBonesParameters(e,this._effect),this.scene.texturesEnabled&&this.material.outlineWidthTexture&&this.material.diffuseTexture){var r=this.material.diffuseTexture;this._effect.setFloat2("vOutlineWidthInfos",r.coordinatesIndex,r.level),r.getTextureMatrix().isIdentityAs3x2()||this._effect.setMatrix("outlineWidthMatrix",r.getTextureMatrix()),this._effect.setTexture("outlineWidthSampler",this.material.outlineWidthTexture)}this._defines.NUM_MORPH_INFLUENCERS&&c.MaterialHelper.BindMorphTargetParameters(e,this._effect),this.scene.fogEnabled&&e.applyFog&&this.scene.fogMode!==M.Scene.FOGMODE_NONE&&this._effect.setMatrix("view",this.scene.getViewMatrix()),this._effect.setMatrix("viewProjection",this.scene.getTransformMatrix()),c.MaterialHelper.BindFogParameters(this.scene,e,this._effect),this._effect.setColor3("vOutlineColor",this.material.outlineColor),this._effect.setFloat("outlineWidth",this.material.outlineWidth),this._effect.setFloat("outlineScaledMaxDistance",this.material.outlineScaledMaxDistance),this._effect.setFloat("outlineLightingMix",this.material.outlineLightingMix),this._effect.setFloat("aspect",this._engine.getAspectRatio(this.scene.activeCamera))}},e.prototype._beforeRenderingMesh=function(e,r,n){this._savedDepthWrite=this._engine.getDepthWrite(),this.willRender(r)&&(this._engine.setDepthWrite(!1),this.render(r.getRenderingMesh(),r,n),this._engine.setDepthWrite(this._savedDepthWrite))},e.prototype._afterRenderingMesh=function(e,r,n){this.willRender(r)&&this._savedDepthWrite&&(this._engine.setDepthWrite(!0),this._engine.setColorWrite(!1),this.render(r.getRenderingMesh(),r,n),this._engine.setColorWrite(!0))},e.prototype.isHardwareInstancedRendering=function(e,r){return this._engine.getCaps().instancedArrays&&null!==r.visibleInstances[e]&&void 0!==r.visibleInstances[e]},e.prototype.willRender=function(e){var r=e.getMaterial();return!(!r||r.name!==this.material.name)&&(!r.needAlphaBlending()&&!r.needAlphaTesting())},e}(),x=(n(13),n(14),n(15).default),y=n(16).default,U=n(17).default,C=n(18).default,A=n(19).default,L=n(20).default;!function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate"}(a||(a={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(s||(s={})),function(e){e[e.None=0]="None",e[e.WorldCorrdinates=1]="WorldCorrdinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}(l||(l={})),function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}(d||(d={}));var R=function(e){function r(r,n){var i=e.call(this,r,n)||this;return i.doNotSerialize=!0,i.diffuseTexture=null,i.emissiveTexture=null,i.bumpTexture=null,i.shadeTexture=null,i.receiveShadowTexture=null,i.shadingGradeTexture=null,i.matCapTexture=null,i.outlineWidthTexture=null,i.maxSimultaneousLights=1,i.specularSupported=!1,i.useVertexColor=!1,i.useBones=!0,i.useMorphTargets=!0,i.useVertexAlpha=!1,i._useLogarithmicDepth=!1,i.disableLighting=!1,i.twoSidedLighting=!1,i.alphaCutOff=.5,i.diffuseColor=new m.Color3(1,1,1),i.ambientColor=new m.Color3(.1,.1,.1),i.globalAmbientColor=new m.Color3(0,0,0),i.emissiveColor=new m.Color3(0,0,0),i.shadeColor=new m.Color3(.97,.81,.86),i.outlineColor=new m.Color3(0,0,0),i._bumpScale=1,i._receiveShadowRate=1,i._shadingGradeRate=1,i._shadeShift=0,i._shadeToony=.9,i._lightColorAttenuation=0,i._indirectLightIntensity=.1,i._outlineWidth=.5,i._outlineScaledMaxDistance=1,i._outlineLightingMix=1,i.alphaTest=!1,i._alphaBlend=!1,i.debugMode=a.None,i._outlineWidthMode=l.None,i.outlineColorMode=s.MixedLighting,i._cullMode=d.Back,i.outlineCullMode=d.Front,i.storedCullMode=d.Back,u.Effect.IncludesShadersStore.mtoonUboDeclaration||(u.Effect.IncludesShadersStore.mtoonUboDeclaration=x,u.Effect.IncludesShadersStore.mtoonVertexDeclaration=y,u.Effect.IncludesShadersStore.mtoonFragmentDeclaration=U,u.Effect.IncludesShadersStore.mtoonLightFragment=C,u.Effect.ShadersStore.mtoonVertexShader=A,u.Effect.ShadersStore.mtoonFragmentShader=L),i}return t(r,e),Object.defineProperty(r.prototype,"appendedTextures",{get:function(){return[this.diffuseTexture,this.emissiveTexture,this.bumpTexture,this.shadeTexture,this.receiveShadowTexture,this.shadingGradeTexture,this.matCapTexture,this.outlineWidthTexture]},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"appendedActiveTextures",{get:function(){return this.appendedTextures.filter(function(e){return null!==e})},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"useLogarithmicDepth",{get:function(){return this._useLogarithmicDepth},set:function(e){var r=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported;this._useLogarithmicDepth!==r&&(this._useLogarithmicDepth=r,this._markAllSubMeshesAsMiscDirty())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"bumpScale",{get:function(){return this._bumpScale},set:function(e){this._bumpScale=e},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"receiveShadowRate",{get:function(){return this._receiveShadowRate},set:function(e){this._receiveShadowRate=Math.max(0,Math.min(1,e))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"shadingGradeRate",{get:function(){return this._shadingGradeRate},set:function(e){this._shadingGradeRate=Math.max(0,Math.min(1,e))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"shadeShift",{get:function(){return this._shadeShift},set:function(e){this._shadeShift=Math.max(-1,Math.min(1,e))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"shadeToony",{get:function(){return this._shadeToony},set:function(e){this._shadeToony=Math.max(0,Math.min(1,e))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"lightColorAttenuation",{get:function(){return this._lightColorAttenuation},set:function(e){this._lightColorAttenuation=Math.max(0,Math.min(1,e))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"indirectLightIntensity",{get:function(){return this._indirectLightIntensity},set:function(e){this._indirectLightIntensity=Math.max(0,Math.min(1,e))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineWidth",{get:function(){return this._outlineWidth},set:function(e){this._outlineWidth=Math.max(.01,Math.min(1,e))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineScaledMaxDistance",{get:function(){return this._outlineScaledMaxDistance},set:function(e){this._outlineScaledMaxDistance=Math.max(1,Math.min(10,e))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineLightingMix",{get:function(){return this._outlineLightingMix},set:function(e){this._outlineLightingMix=Math.max(0,Math.min(1,e))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"alphaBlend",{get:function(){return this._alphaBlend},set:function(e){this._alphaBlend=e,e&&(this.backFaceCulling=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineWidthMode",{get:function(){return this._outlineWidthMode},set:function(e){this._outlineWidthMode=e,e===l.None||this.outlineRenderer||(this.outlineRenderer=new b(this.getScene(),this))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"cullMode",{get:function(){return this._cullMode},set:function(e){switch(this._cullMode=e,this._cullMode){case d.Off:this.backFaceCulling=!1,this.sideOrientation=h.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1;break;case d.Front:this.backFaceCulling=!0,this.sideOrientation=h.Material.CounterClockWiseSideOrientation,this.twoSidedLighting=!0;break;case d.Back:this.backFaceCulling=!0,this.sideOrientation=h.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1}},enumerable:!0,configurable:!0}),r.prototype.applyOutlineCullMode=function(){this.storedCullMode=this.cullMode,this.cullMode=this.outlineCullMode},r.prototype.restoreOutlineCullMode=function(){this.cullMode=this.storedCullMode},r.prototype.isReadyForSubMesh=function(e,r,n){if(void 0===n&&(n=!1),r.effect&&this.isFrozen&&this._wasPreviouslyReady)return!0;r._materialDefines||(r._materialDefines=new T);var i=this.getScene(),t=r._materialDefines;if(!this.checkReadyOnEveryCall&&r.effect&&t._renderId===i.getRenderId())return!0;var o=i.getEngine();if(t._needNormals=c.MaterialHelper.PrepareDefinesForLights(i,e,t,this.specularSupported,this.maxSimultaneousLights,this.disableLighting),c.MaterialHelper.PrepareDefinesForMultiview(i,t),t._areTexturesDirty){if(t._needUVs=!1,t.MAINUV1=!1,t.MAINUV2=!1,i.texturesEnabled){if(!(this.isReadyForTexture(this.diffuseTexture,t,"DIFFUSE")&&this.isReadyForTexture(this.emissiveTexture,t,"EMISSIVE")&&this.isReadyForTexture(this.shadeTexture,t,"SHADE")&&this.isReadyForTexture(this.receiveShadowTexture,t,"RECEIVE_SHADOW")&&this.isReadyForTexture(this.shadingGradeTexture,t,"SHADING_GRADE")&&this.isReadyForTexture(this.matCapTexture,t,"MATCAP")&&this.isReadyForTexture(this.outlineWidthTexture,t,"OUTLINE_WIDTH")))return!1;if(i.getEngine().getCaps().standardDerivatives&&this.bumpTexture){if(!this.bumpTexture.isReady())return!1;c.MaterialHelper.PrepareDefinesForMergedUV(this.bumpTexture,t,"BUMP")}else t.BUMP=!1;t.TWOSIDEDLIGHTING=!this._backFaceCulling&&this.twoSidedLighting}else t.DIFFUSE=!1,t.EMISSIVE=!1,t.SHADE=!1,t.RECEIVE_SHADOW=!1,t.SHADING_GRADE=!1,t.MATCAP=!1,t.OUTLINE_WIDTH=!1,t.BUMP=!1;t.PREMULTIPLYALPHA=this.alphaMode===f.Constants.ALPHA_PREMULTIPLIED||this.alphaMode===f.Constants.ALPHA_PREMULTIPLIED_PORTERDUFF}if(c.MaterialHelper.PrepareDefinesForMisc(e,i,this.useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(e),t),c.MaterialHelper.PrepareDefinesForAttributes(e,t,this.useVertexColor,this.useBones,this.useMorphTargets,this.useVertexAlpha),c.MaterialHelper.PrepareDefinesForFrameBoundValues(i,o,t,n),t.isDirty){t.markAsProcessed();var a=new u.EffectFallbacks;t.BUMP&&a.addFallback(0,"BUMP"),t.FOG&&a.addFallback(1,"FOG"),t.POINTSIZE&&a.addFallback(0,"POINTSIZE"),t.LOGARITHMICDEPTH&&a.addFallback(0,"LOGARITHMICDEPTH"),c.MaterialHelper.HandleFallbacksForShadows(t,a,this.maxSimultaneousLights),t.MULTIVIEW&&a.addFallback(0,"MULTIVIEW");var s=[v.VertexBuffer.PositionKind];t.NORMAL&&s.push(v.VertexBuffer.NormalKind),t.TANGENT&&s.push(v.VertexBuffer.TangentKind),t.UV1&&s.push(v.VertexBuffer.UVKind),t.UV2&&s.push(v.VertexBuffer.UV2Kind),c.MaterialHelper.PrepareAttributesForBones(s,e,t,a),c.MaterialHelper.PrepareAttributesForInstances(s,t),c.MaterialHelper.PrepareAttributesForMorphTargets(s,e,t);var l=["world","view","viewProjection","vLightsType","visibility","mBones","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vFogInfos","vFogColor","pointSize","alphaCutOff","logarithmicDepthConstant","vTangentSpaceParams","boneTextureWidth","vDiffuseColor","vDiffuseInfos","diffuseMatrix","vEmissiveColor","vEmissiveInfos","emissiveMatrix","vBumpInfos","bumpMatrix","vShadeColor","vShadeInfos","shadeMatrix","vReceiveShadowInfos","receiveShadowMatrix","vShadingGradeInfos","shadingGradeMatrix","vMatCapInfos","MatCapMatrix","vOutlineColor","vOutlineWidthInfos","outlineWidthMatrix","shadingGradeRate","receiveShadowRate","shadeShift","shadeToony","lightColorAttenuation","indirectLightIntensity","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","vEyePosition","vEyeUp"],d=["diffuseSampler","emissiveSampler","bumpSampler","boneSampler","shadeSampler","receiveShadowSampler","shadingGradeSampler","matCapSampler","outlineWidthSampler"],h=["Material","Scene"];c.MaterialHelper.PrepareUniformsAndSamplersList({uniformsNames:l,uniformBuffersNames:h,samplers:d,defines:t,maxSimultaneousLights:this.maxSimultaneousLights}),this.applyDefines(t);var p=t.toString(),m=r.effect,g=i.getEngine().createEffect("mtoon",{attributes:s,uniformsNames:l,uniformBuffersNames:h,samplers:d,defines:p,fallbacks:a,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this.maxSimultaneousLights,maxSimultaneousMorphTargets:t.NUM_MORPH_INFLUENCERS}},o);g&&(this.allowShaderHotSwapping&&m&&!g.isReady()?(g=m,t.markAsUnprocessed()):(i.resetCachedMaterial(),r.setEffect(g,t),this.buildUniformLayout()))}return!(!r.effect||!r.effect.isReady())&&(t._renderId=i.getRenderId(),this._wasPreviouslyReady=!0,!0)},r.prototype.bindForSubMesh=function(e,r,n){var i=this.getScene(),t=n._materialDefines,o=n.effect;if(t&&o){this._activeEffect=o,this.bindOnlyWorldMatrix(e),this.applyDefines(t),c.MaterialHelper.BindBonesParameters(r,o);var a=i.isCachedMaterialInvalid(this,o,r.visibility);if(a){if(this._uniformBuffer.bindToEffect(o,"Material"),this.bindViewProjection(o),(!this._uniformBuffer.useUbo||!this.isFrozen||!this._uniformBuffer.isSync)&&i.texturesEnabled){if(this.bindTexture(this.diffuseTexture,o,"diffuse","vDiffuseInfos"),o.setFloat("alphaCutOff",this.alphaCutOff),this.bindTexture(this.emissiveTexture,o,"emissive","vEmissiveInfos"),this.bumpTexture){this._uniformBuffer.updateFloat3("vBumpInfos",this.bumpTexture.coordinatesIndex,1/this.bumpTexture.level,this.bumpScale);var s=this.bumpTexture.getTextureMatrix();s.isIdentityAs3x2()||this._uniformBuffer.updateMatrix("bumpMatrix",s),o.setTexture("bumpSampler",this.bumpTexture),i._mirroredCameraPosition?this._uniformBuffer.updateFloat2("vTangentSpaceParams",1,1):this._uniformBuffer.updateFloat2("vTangentSpaceParams",-1,-1)}this.bindTexture(this.shadeTexture,o,"shade","vShadeInfos"),this.bindTexture(this.receiveShadowTexture,o,"receiveShadow","vReceiveShadowInfos"),this.bindTexture(this.shadingGradeTexture,o,"shadingGrade","vShadingGradeInfos"),this.bindTexture(this.matCapTexture,o,"matCap","vMatCapInfos"),this.bindTexture(this.outlineWidthTexture,o,"outlineWidth","vOutlineWidthInfos")}this.pointsCloud&&this._uniformBuffer.updateFloat("pointSize",this.pointSize),this._uniformBuffer.updateFloat("visibility",r.visibility),this._uniformBuffer.updateFloat("receiveShadowRate",this.receiveShadowRate),this._uniformBuffer.updateFloat("shadingGradeRate",this.shadingGradeRate),this._uniformBuffer.updateFloat("shadeShift",this.shadeShift),this._uniformBuffer.updateFloat("shadeToony",this.shadeToony),this._uniformBuffer.updateFloat("lightColorAttenuation",this.lightColorAttenuation),this._uniformBuffer.updateFloat("indirectLightIntensity",this.indirectLightIntensity),this._uniformBuffer.updateFloat("outlineWidth",this.outlineWidth),this._uniformBuffer.updateFloat("outlineScaledMaxDistance",this.outlineScaledMaxDistance),this._uniformBuffer.updateFloat("outlineLightingMix",this.outlineLightingMix),c.MaterialHelper.BindClipPlane(o,i),i.ambientColor.multiplyToRef(this.ambientColor,this.globalAmbientColor),o.setColor3("vAmbientColor",this.globalAmbientColor),this._uniformBuffer.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),this._uniformBuffer.updateColor3("vEmissiveColor",this.emissiveColor),this._uniformBuffer.updateColor3("vShadeColor",this.shadeColor),this._uniformBuffer.updateColor3("vOutlineColor",this.outlineColor),c.MaterialHelper.BindEyePosition(o,i),o.setVector3("vEyeUp",i.activeCamera.upVector)}!a&&this.isFrozen||(i.lightsEnabled&&!this.disableLighting&&c.MaterialHelper.BindLights(i,r,o,t,this.maxSimultaneousLights),i.fogEnabled&&r.applyFog&&i.fogMode!==M.Scene.FOGMODE_NONE&&this.bindView(o),c.MaterialHelper.BindFogParameters(i,r,o),t.NUM_MORPH_INFLUENCERS&&c.MaterialHelper.BindMorphTargetParameters(r,o),c.MaterialHelper.BindLogDepth(t,o,i)),this._uniformBuffer.update(),this._afterBind(r,this._activeEffect)}},r.prototype.getAnimatables=function(){for(var e=[],r=0,n=this.appendedActiveTextures;r<n.length;r++){var i=n[r];i.animations&&i.animations.length>0&&e.push(i)}return e},r.prototype.getActiveTextures=function(){return e.prototype.getActiveTextures.call(this).concat(this.appendedActiveTextures)},r.prototype.hasTexture=function(r){return!!e.prototype.hasTexture.call(this,r)||this.appendedActiveTextures.length>0},r.prototype.dispose=function(r,n,i){if(delete this.outlineRenderer,n)for(var t=0,o=this.appendedActiveTextures;t<o.length;t++){o[t].dispose()}e.prototype.dispose.call(this,r,n,i)},r.prototype.buildUniformLayout=function(){this._uniformBuffer.addUniform("vDiffuseColor",4),this._uniformBuffer.addUniform("vDiffuseInfos",2),this._uniformBuffer.addUniform("diffuseMatrix",16),this._uniformBuffer.addUniform("vEmissiveColor",3),this._uniformBuffer.addUniform("vEmissiveInfos",2),this._uniformBuffer.addUniform("emissiveMatrix",16),this._uniformBuffer.addUniform("vBumpInfos",3),this._uniformBuffer.addUniform("bumpMatrix",16),this._uniformBuffer.addUniform("vShadeColor",3),this._uniformBuffer.addUniform("vShadeInfos",2),this._uniformBuffer.addUniform("shadeMatrix",16),this._uniformBuffer.addUniform("vReceiveShadowInfos",2),this._uniformBuffer.addUniform("receiveShadowMatrix",16),this._uniformBuffer.addUniform("vShadingGradeInfos",2),this._uniformBuffer.addUniform("shadingGradeMatrix",16),this._uniformBuffer.addUniform("vMatCapInfos",2),this._uniformBuffer.addUniform("matCapMatrix",16),this._uniformBuffer.addUniform("vOutlineColor",3),this._uniformBuffer.addUniform("vOutlineWidthInfos",2),this._uniformBuffer.addUniform("outlineWidthMatrix",16),this._uniformBuffer.addUniform("vTangentSpaceParams",2),this._uniformBuffer.addUniform("pointSize",1),this._uniformBuffer.addUniform("visibility",1),this._uniformBuffer.addUniform("shadingGradeRate",1),this._uniformBuffer.addUniform("receiveShadowRate",1),this._uniformBuffer.addUniform("shadeShift",1),this._uniformBuffer.addUniform("shadeToony",1),this._uniformBuffer.addUniform("lightColorAttenuation",1),this._uniformBuffer.addUniform("indirectLightIntensity",1),this._uniformBuffer.addUniform("outlineWidth",1),this._uniformBuffer.addUniform("outlineScaledMaxDistance",1),this._uniformBuffer.addUniform("outlineLightingMix",1),this._uniformBuffer.create()},r.prototype.bindTexture=function(e,r,n,i){if(e){this._uniformBuffer.updateFloat2(i,e.coordinatesIndex,e.level);var t=e.getTextureMatrix();t.isIdentityAs3x2()||this._uniformBuffer.updateMatrix(n+"Matrix",t),r.setTexture(n+"Sampler",e)}},r.prototype.isReadyForTexture=function(e,r,n){return e?!!e.isReadyOrNotBlocking()&&(c.MaterialHelper.PrepareDefinesForMergedUV(e,r,n),!0):(r[n]=!1,!0)},r.prototype.applyDefines=function(e){switch(this.debugMode){case a.Normal:!0!==e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!0,e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed());break;case a.LitShadeRate:!0!==e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_NORMAL=!1,e.MTOON_DEBUG_LITSHADERATE=!0,e.markAsUnprocessed());break;case a.None:!0===e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!1,e.markAsUnprocessed()),!0===e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed())}switch(this.outlineWidthMode){case l.WorldCorrdinates:!0!==e.MTOON_OUTLINE_WIDTH_WORLD&&(e.MTOON_OUTLINE_WIDTH_WORLD=!0,e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.markAsUnprocessed());break;case l.ScreenCoordinates:!0!==e.MTOON_OUTLINE_WIDTH_SCREEN&&(e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.MTOON_OUTLINE_WIDTH_SCREEN=!0,e.markAsUnprocessed());break;case l.None:!1===e.MTOON_OUTLINE_WIDTH_SCREEN&&!1===e.MTOON_OUTLINE_WIDTH_WORLD||(e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.markAsUnprocessed())}switch(this.outlineColorMode){case s.FixedColor:!0!==e.MTOON_OUTLINE_COLOR_FIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!0,e.MTOON_OUTLINE_COLOR_MIXED=!1,e.markAsUnprocessed());break;case s.MixedLighting:!0!==e.MTOON_OUTLINE_COLOR_MIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!1,e.MTOON_OUTLINE_COLOR_MIXED=!0,e.markAsUnprocessed())}},r.prototype.getClassName=function(){return"MToonMaterial"},r.prototype.getAlphaTestTexture=function(){return this.diffuseTexture},r.prototype.needAlphaBlending=function(){return this.alphaBlend},r.prototype.needAlphaTesting=function(){return this.alphaTest},r.prototype.clone=function(e){throw new Error("MToonMaterial cannot be cloned.")},r.prototype.serialize=function(){throw new Error("MToonMaterial cannot be serialized")},r.Parse=function(e,r,n){throw new Error("MToonMaterial cannot be parsed")},o([Object(g.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"diffuseTexture",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"emissiveTexture",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"bumpTexture",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"shadeTexture",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"receiveShadowTexture",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"shadingGradeTexture",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"matCapTexture",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"outlineWidthTexture",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"disableLighting",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"twoSidedLighting",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"alphaCutOff",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"diffuseColor",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"ambientColor",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"emissiveColor",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"shadeColor",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"outlineColor",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"receiveShadowRate",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"shadingGradeRate",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"shadeShift",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"shadeToony",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"lightColorAttenuation",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"indirectLightIntensity",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsAttributesDirty")],r.prototype,"outlineWidth",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsAttributesDirty")],r.prototype,"outlineScaledMaxDistance",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsAttributesDirty")],r.prototype,"outlineLightingMix",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"alphaTest",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"alphaBlend",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"debugMode",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"outlineWidthMode",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"outlineColorMode",void 0),o([Object(g.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"cullMode",null),o([Object(g.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"outlineCullMode",void 0),r}(p.PushMaterial);n.d(r,"MToonMaterial",function(){return R})}])});