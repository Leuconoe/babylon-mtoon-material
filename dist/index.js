!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r(require("@babylonjs/core/Misc/decorators"),require("@babylonjs/core/Misc/iInspectable"),require("@babylonjs/core/Materials/materialHelper"),require("@babylonjs/core/Materials/effect"),require("@babylonjs/core/Maths/math"),require("@babylonjs/core/Materials/material"),require("@babylonjs/core/Meshes/buffer"),require("@babylonjs/core/Engines/constants"),require("@babylonjs/core/sceneComponent"),require("@babylonjs/core/Materials/pushMaterial"),require("@babylonjs/core/scene"),require("@babylonjs/core/Materials/materialDefines"),require("@babylonjs/core/Rendering/edgesRenderer"),require("@babylonjs/core/Rendering/outlineRenderer")):"function"==typeof define&&define.amd?define(["@babylonjs/core/Misc/decorators","@babylonjs/core/Misc/iInspectable","@babylonjs/core/Materials/materialHelper","@babylonjs/core/Materials/effect","@babylonjs/core/Maths/math","@babylonjs/core/Materials/material","@babylonjs/core/Meshes/buffer","@babylonjs/core/Engines/constants","@babylonjs/core/sceneComponent","@babylonjs/core/Materials/pushMaterial","@babylonjs/core/scene","@babylonjs/core/Materials/materialDefines","@babylonjs/core/Rendering/edgesRenderer","@babylonjs/core/Rendering/outlineRenderer"],r):"object"==typeof exports?exports["babylon-mtoon-material"]=r(require("@babylonjs/core/Misc/decorators"),require("@babylonjs/core/Misc/iInspectable"),require("@babylonjs/core/Materials/materialHelper"),require("@babylonjs/core/Materials/effect"),require("@babylonjs/core/Maths/math"),require("@babylonjs/core/Materials/material"),require("@babylonjs/core/Meshes/buffer"),require("@babylonjs/core/Engines/constants"),require("@babylonjs/core/sceneComponent"),require("@babylonjs/core/Materials/pushMaterial"),require("@babylonjs/core/scene"),require("@babylonjs/core/Materials/materialDefines"),require("@babylonjs/core/Rendering/edgesRenderer"),require("@babylonjs/core/Rendering/outlineRenderer")):e["babylon-mtoon-material"]=r(e["@babylonjs/core/Misc/decorators"],e["@babylonjs/core/Misc/iInspectable"],e["@babylonjs/core/Materials/materialHelper"],e["@babylonjs/core/Materials/effect"],e["@babylonjs/core/Maths/math"],e["@babylonjs/core/Materials/material"],e["@babylonjs/core/Meshes/buffer"],e["@babylonjs/core/Engines/constants"],e["@babylonjs/core/sceneComponent"],e["@babylonjs/core/Materials/pushMaterial"],e["@babylonjs/core/scene"],e["@babylonjs/core/Materials/materialDefines"],e["@babylonjs/core/Rendering/edgesRenderer"],e["@babylonjs/core/Rendering/outlineRenderer"])}(window,function(e,r,i,n,t,o,a,s,l,d,f,u,h,c){return function(e){var r={};function i(n){if(r[n])return r[n].exports;var t=r[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,i),t.l=!0,t.exports}return i.m=e,i.c=r,i.d=function(e,r,n){i.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:n})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,r){if(1&r&&(e=i(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var t in e)i.d(n,t,function(r){return e[r]}.bind(null,t));return n},i.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(r,"a",r),r},i.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},i.p="",i(i.s=20)}([function(r,i){r.exports=e},function(e,i){e.exports=r},function(e,r){e.exports=i},function(e,r){e.exports=n},function(e,r){e.exports=t},function(e,r){e.exports=o},function(e,r){e.exports=a},function(e,r){e.exports=s},function(e,r){e.exports=l},function(e,r){e.exports=d},function(e,r){e.exports=f},function(e,r){e.exports=u},function(e,r){e.exports=h},function(e,r){e.exports=c},function(e,r,i){"use strict";i.r(r),r.default="// include<__decl__mtoonVertex> または include<__decl__mtoonFragment> と書いた時に展開される\r\n// @see effect.ts\r\n\r\nlayout(std140, column_major) uniform;\r\n\r\nuniform Material\r\n{\r\n    vec4 vDiffuseColor;\r\n    vec2 vDiffuseInfos;\r\n    mat4 diffuseMatrix;\r\n    vec4 vEmissiveColor;\r\n    vec2 vEmissiveInfos;\r\n    mat4 emissiveMatrix;\r\n    vec3 vBumpInfos;\r\n    mat4 bumpMatrix;\r\n    vec3 vShadeColor;\r\n    vec2 vShadeInfos;\r\n    mat4 shadeMatrix;\r\n    vec2 vReceiveShadowInfos;\r\n    mat4 receiveShadowMatrix;\r\n    vec2 vShadingGradeInfos;\r\n    mat4 shadingGradeMatrix;\r\n    vec3 vRimColor;\r\n    vec2 vRimInfos;\r\n    mat4 rimMatrix;\r\n    vec2 vMatCapInfos;\r\n    mat4 matCapMatrix;\r\n    vec4 vOutlineColor;\r\n    vec2 vOutlineWidthInfos;\r\n    mat4 outlineWidthMatrix;\r\n    vec2 vTangentSpaceParams;\r\n    float pointSize;\r\n    float visibility;\r\n    float shadingGradeRate;\r\n    float receiveShadowRate;\r\n    float shadeShift;\r\n    float shadeToony;\r\n    float lightColorAttenuation;\r\n    float indirectLightIntensity;\r\n    float rimLightingMix;\r\n    float rimFresnelPower;\r\n    float rimLift;\r\n    float outlineWidth;\r\n    float outlineScaledMaxDistance;\r\n    float outlineLightingMix;\r\n};\r\n\r\nuniform Scene {\r\n    mat4 viewProjection;\r\n#ifdef MULTIVIEW\r\n    mat4 viewProjectionR;\r\n#endif\r\n    mat4 view;\r\n};\r\n"},function(e,r,i){"use strict";i.r(r),r.default="// Uniforms\r\nuniform mat4 viewProjection;\r\nuniform mat4 view;\r\nuniform float outlineWidth;\r\nuniform float outlineScaledMaxDistance;\r\nuniform float outlineLightingMix;\r\n\r\n#ifdef DIFFUSE\r\nuniform mat4 diffuseMatrix;\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nuniform vec2 vEmissiveInfos;\r\nuniform mat4 emissiveMatrix;\r\n#endif\r\n\r\n#ifdef BUMP\r\nuniform vec3 vBumpInfos;\r\nuniform mat4 bumpMatrix;\r\n#endif\r\n\r\n#ifdef SHADE\r\nuniform vec2 vShadeInfos;\r\nuniform mat4 shadeMatrix;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOW\r\nuniform vec2 vReceiveShadowInfos;\r\nuniform mat4 receiveShadowMatrix;\r\n#endif\r\n\r\n#ifdef SHADING_GRADE\r\nuniform vec2 vShadingGradeInfos;\r\nuniform mat4 shadingGradeMatrix;\r\n#endif\r\n\r\n#ifdef RIM\r\nuniform vec2 vRimInfos;\r\nuniform mat4 rimMatrix;\r\n#endif\r\n\r\n#ifdef MATCAP\r\nuniform vec2 vMatCapInfos;\r\nuniform mat4 matCapMatrix;\r\n#endif\r\n\r\n#ifdef OUTLINE_WIDTH\r\nuniform vec2 vOutlineWidthInfos;\r\nuniform mat4 outlineWidthMatrix;\r\n#endif\r\n\r\n#ifdef POINTSIZE\r\nuniform float pointSize;\r\n#endif\r\n"},function(e,r,i){"use strict";i.r(r),r.default="uniform mat4 viewProjection;\r\nuniform mat4 view;\r\nuniform vec4 vDiffuseColor;\r\nuniform vec3 vEmissiveColor;\r\nuniform vec3 vShadeColor;\r\nuniform vec3 vRimColor;\r\nuniform vec4 vOutlineColor;\r\n\r\nuniform float visibility;\r\n\r\n// Samplers\r\n#ifdef DIFFUSE\r\nuniform vec2 vDiffuseInfos;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\nuniform vec2 vEmissiveInfos;\r\n#endif\r\n\r\n#ifdef BUMP\r\nuniform vec3 vBumpInfos;\r\nuniform vec2 vTangentSpaceParams;\r\n#endif\r\n\r\n#ifdef SHADE\r\nuniform vec2 vShadeInfos;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOW\r\nuniform vec2 vReceiveShadowInfos;\r\n#endif\r\n\r\n#ifdef SHADING_GRADE\r\nuniform vec2 vShadingGradeInfos;\r\n#endif\r\n\r\n#ifdef RIM\r\nuniform vec2 vRimInfos;\r\n#endif\r\n\r\n#ifdef MATCAP\r\nuniform vec2 vMatCapInfos;\r\n#endif\r\n\r\n#ifdef OUTLINE_WIDTH\r\nuniform vec2 vOutlineWidthInfos;\r\n#endif\r\n\r\nuniform float shadingGradeRate;\r\nuniform float receiveShadowRate;\r\nuniform float shadeShift;\r\nuniform float shadeToony;\r\nuniform float lightColorAttenuation;\r\nuniform float indirectLightIntensity;\r\nuniform float rimLightingMix;\r\nuniform float rimFresnelPower;\r\nuniform float rimLift;\r\nuniform float outlineWidth;\r\nuniform float outlineScaledMaxDistance;\r\nuniform float outlineLightingMix;\r\n"},function(e,r,i){"use strict";i.r(r),r.default="#ifdef LIGHT{X}\r\n    // 影の計算は流用\r\n    #ifdef SHADOW{X}\r\n        #ifdef SHADOWCLOSEESM{X}\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWESM{X})\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWPOISSON{X})\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWPCF{X})\r\n            #if defined(SHADOWLOWQUALITY{X})\r\n                shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #elif defined(SHADOWMEDIUMQUALITY{X})\r\n                shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #else\r\n                shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #elif defined(SHADOWPCSS{X})\r\n            #if defined(SHADOWLOWQUALITY{X})\r\n                shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #elif defined(SHADOWMEDIUMQUALITY{X})\r\n                shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #else\r\n                shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #else\r\n            #if defined(SHADOWCUBE{X})\r\n                shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\r\n            #else\r\n                shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\r\n            #endif\r\n        #endif\r\n    #else\r\n        shadow = 1.;\r\n    #endif\r\n\r\n    // ここで MToon のライティングを適用\r\n    #ifdef SPOTLIGHT{X}\r\n        lightDirection = computeSpotLightDirection(light{X}.vLightData);\r\n    #elif defined(HEMILIGHT{X})\r\n        lightDirection = computeHemisphericLightDirection(light{X}.vLightData, normalW.xyz);\r\n    #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\r\n        lightDirection = computeLightDirection(light{X}.vLightData);\r\n    #endif\r\n    mtoonDiffuse = computeMToonDiffuseLighting(viewDirectionW.xyz, normalW.xyz, uvOffset, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\r\n    diffuseBase = mtoonDiffuse.rgb;\r\n    alpha = alpha * mtoonDiffuse.a;\r\n    #ifdef ALPHATEST\r\n        if (alpha < alphaCutOff) {\r\n            discard;\r\n        }\r\n    #endif\r\n\r\n    #ifdef SPECULARTERM\r\n        specularBase += info.specular * shadow;\r\n    #endif\r\n    #ifdef CLEARCOAT\r\n        clearCoatBase += info.clearCoat.rgb * shadow;\r\n    #endif\r\n    #ifdef SHEEN\r\n        sheenBase += info.sheen.rgb * shadow;\r\n    #endif\r\n#endif\r\n"},function(e,r,i){"use strict";i.r(r),r.default="// この include は特別で、 UboDeclaration または VertexDeclaration のどちらかに置換される\r\n// @see effect.ts\r\n#include<__decl__mtoonVertex>\r\n\r\n// 基本的に default.vertex.fx のまま\r\n\r\n// Attributes\r\n\r\nattribute vec3 position;\r\n#ifdef NORMAL\r\nattribute vec3 normal;\r\n#endif\r\n#ifdef TANGENT\r\nattribute vec4 tangent;\r\n#endif\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n\r\n#include<helperFunctions>\r\n\r\n#include<bonesDeclaration>\r\n\r\n// Uniforms\r\n#include<instancesDeclaration>\r\n\r\n#ifdef MAINUV1\r\nvarying vec2 vMainUV1;\r\n#endif\r\n\r\n#ifdef MAINUV2\r\nvarying vec2 vMainUV2;\r\n#endif\r\n\r\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\r\nvarying vec2 vDiffuseUV;\r\n#endif\r\n\r\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\r\nvarying vec2 vEmissiveUV;\r\n#endif\r\n\r\n#if defined(BUMP) && BUMPDIRECTUV == 0\r\nvarying vec2 vBumpUV;\r\n#endif\r\n\r\n// Output\r\nvarying vec3 vPositionW;\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#include<bumpVertexDeclaration>\r\n\r\n#include<clipPlaneVertexDeclaration>\r\n\r\n#include<fogVertexDeclaration>\r\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\r\n\r\n#include<morphTargetsVertexGlobalDeclaration>\r\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\r\n\r\n#include<logDepthDeclaration>\r\n\r\n\r\n// Additional Uniforms\r\n#if defined(SHADE) && SHADEDIRECTUV == 0\r\n    varying vec2 vShadeUV;\r\n#endif\r\n#if defined(RECEIVE_SHADOW) && RECEIVE_SHADOWDIRECTUV == 0\r\n    varying vec2 vReceiveShadowUV;\r\n#endif\r\n#if defined(SHADING_GRADE) && SHADING_GRADEDIRECTUV == 0\r\n    varying vec2 vShadingGradeUV;\r\n#endif\r\n#if defined(RIM) && RIMDIRECTUV == 0\r\n    varying vec2 vRimUV;\r\n#endif\r\n#if defined(MATCAP) && MATCAPDIRECTUV == 0\r\n    varying vec2 vMatCapUV;\r\n#endif\r\n#if defined(OUTLINE_WIDTH) && OUTLINE_WIDTHDIRECTUV == 0\r\n    varying vec2 vOutlineWidthUV;\r\n#endif\r\n#ifdef OUTLINE_WIDTH\r\n    uniform sampler2D outlineWidthSampler;\r\n#endif\r\n\r\nuniform float aspect;\r\nuniform float isOutline;\r\n\r\nvoid main(void) {\r\n\r\n    vec3 positionUpdated = position;\r\n#ifdef NORMAL\r\n    vec3 normalUpdated = normal;\r\n#endif\r\n#ifdef TANGENT\r\n    vec4 tangentUpdated = tangent;\r\n#endif\r\n\r\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\r\n\r\n#include<instancesVertex>\r\n#include<bonesVertex>\r\n\r\n    // Texture coordinates\r\n#ifndef UV1\r\n    vec2 uv = vec2(0., 0.);\r\n#endif\r\n#ifndef UV2\r\n    vec2 uv2 = vec2(0., 0.);\r\n#endif\r\n\r\n#ifdef MAINUV1\r\n    vMainUV1 = uv;\r\n#endif\r\n\r\n#ifdef MAINUV2\r\n    vMainUV2 = uv2;\r\n#endif\r\n\r\n    float outlineTex = 1.0;\r\n    if (isOutline == 1.0) {\r\n#ifdef OUTLINE_WIDTH\r\n    #if OUTLINE_WIDTHDIRECTUV == 0\r\n        if (vOutlineWidthInfos.x == 0.) {\r\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv, 1.0, 0.0));\r\n        } else {\r\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv2, 1.0, 0.0));\r\n        }\r\n    #elif defined(MAINUV1)\r\n        vec2 vOutlineWidthUV = vMainUV1;\r\n    #elif defined(MAINUV2)\r\n        vec2 vOutlineWidthUV = vMainUV2;\r\n    #else\r\n        vec2 vOutlineWidthUV = vec2(0., 0.);\r\n    #endif\r\n    outlineTex = texture2D(outlineWidthSampler, vOutlineWidthUV).r * vOutlineWidthInfos.y;\r\n#endif\r\n\r\n#ifdef MTOON_OUTLINE_WIDTH_WORLD\r\n        // ワールド座標の normal 分だけ移動する\r\n        vec3 outlineOffset = normalize(finalWorld * vec4(normalUpdated, 1.0)).xyz * 0.01 * outlineWidth * outlineTex;\r\n        positionUpdated.xyz += outlineOffset;\r\n#endif\r\n    }\r\n\r\n    vec4 vertex = vec4(1.0);\r\n#ifdef MULTIVIEW\r\n    if (gl_ViewID_OVR == 0u) {\r\n        vertex = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\r\n    } else {\r\n        vertex = viewProjectionR * finalWorld * vec4(positionUpdated, 1.0);\r\n    }\r\n#else\r\n    vertex = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\r\n#endif\r\n\r\n#ifdef MTOON_OUTLINE_WIDTH_SCREEN\r\n    if (isOutline == 1.0) {\r\n        vec4 projectedNormal = normalize(viewProjection * finalWorld * vec4(normalUpdated, 1.0));\r\n        projectedNormal *= min(vertex.w, outlineScaledMaxDistance);\r\n        projectedNormal.x *= aspect;\r\n        vertex.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\r\n    }\r\n#endif\r\n\r\n    gl_Position = vertex;\r\n\r\n    vec4 worldPos = finalWorld * vec4(vertex.xyz, 1.0);\r\n    vPositionW = vec3(worldPos);\r\n\r\n#ifdef NORMAL\r\n    mat3 normalWorld = mat3(finalWorld);\r\n\r\n    #ifdef NONUNIFORMSCALING\r\n        normalWorld = transposeMat3(inverseMat3(normalWorld));\r\n    #endif\r\n\r\n    vNormalW = normalize(normalWorld * normalUpdated);\r\n#endif\r\n\r\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\r\n    if (vDiffuseInfos.x == 0.)\r\n    {\r\n        vDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\r\n    }\r\n    else\r\n    {\r\n        vDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\r\n    if (vEmissiveInfos.x == 0.)\r\n    {\r\n        vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\r\n    }\r\n    else\r\n    {\r\n        vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#if defined(BUMP) && BUMPDIRECTUV == 0\r\n    if (vBumpInfos.x == 0.)\r\n    {\r\n        vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\r\n    }\r\n    else\r\n    {\r\n        vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#if defined(SHADE) && SHADEDIRECTUV == 0\r\n    if (vShadeInfos.x == 0.) {\r\n        vShadeUV = vec2(shadeMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vShadeUV = vec2(shadeMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(RECEIVE_SHADOW) && RECEIVE_SHADOWDIRECTUV == 0\r\n    if (vReceiveShadowInfos.x == 0.) {\r\n        vReceiveShadowUV = vec2(receiveShadowMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vReceiveShadowUV = vec2(receiveShadowMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(SHADING_GRADE) && SHADING_GRADEDIRECTUV == 0\r\n    if (vShadingGradeInfos.x == 0.) {\r\n        vShadingGradeUV = vec2(shadingGradeMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vShadingGradeUV = vec2(shadingGradeMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(RIM) && RIMDIRECTUV == 0\r\n    if (vRimInfos.x == 0.) {\r\n        vRimUV = vec2(rimMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vRimUV = vec2(rimMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n#if defined(MATCAP) && MATCAPDIRECTUV == 0\r\n    if (vMatCapInfos.x == 0.) {\r\n        vMatCapUV = vec2(matCapMatrix * vec4(uv, 1.0, 0.0));\r\n    } else {\r\n        vMatCapUV = vec2(matCapMatrix * vec4(uv2, 1.0, 0.0));\r\n    }\r\n#endif\r\n\r\n#include<bumpVertex>\r\n#include<clipPlaneVertex>\r\n#include<fogVertex>\r\n#include<shadowsVertex>[0..maxSimultaneousLights]\r\n\r\n#include<pointCloudVertex>\r\n#include<logDepthVertex>\r\n\r\n}\r\n"},function(e,r,i){"use strict";i.r(r),r.default="#include<__decl__mtoonFragment>\r\n\r\n#if defined(BUMP) || !defined(NORMAL)\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\n#ifdef LOGARITHMICDEPTH\r\n#extension GL_EXT_frag_depth : enable\r\n#endif\r\n\r\n// Constants\r\n#define RECIPROCAL_PI2 0.15915494\r\n\r\nuniform vec3 vEyePosition;\r\nuniform vec3 vEyeUp;\r\nuniform vec3 vAmbientColor;\r\nuniform float aspect;\r\nuniform float isOutline;\r\n\r\n// Input\r\nvarying vec3 vPositionW;\r\n\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#ifdef MAINUV1\r\n    varying vec2 vMainUV1;\r\n#endif\r\n\r\n#ifdef MAINUV2\r\n    varying vec2 vMainUV2;\r\n#endif\r\n\r\n// Helper functions\r\n#include<helperFunctions>\r\n\r\n// Lights\r\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\r\n\r\n#include<lightsFragmentFunctions>\r\n#include<shadowsFragmentFunctions>\r\n\r\n// Samplers\r\n#ifdef DIFFUSE\r\n    #if DIFFUSEDIRECTUV == 1\r\n        #define vDiffuseUV vMainUV1\r\n    #elif DIFFUSEDIRECTUV == 2\r\n        #define vDiffuseUV vMainUV2\r\n    #else\r\n        varying vec2 vDiffuseUV;\r\n    #endif\r\n    uniform sampler2D diffuseSampler;\r\n#endif\r\n\r\n#ifdef EMISSIVE\r\n    #if EMISSIVEDIRECTUV == 1\r\n        #define vEmissiveUV vMainUV1\r\n    #elif EMISSIVEDIRECTUV == 2\r\n        #define vEmissiveUV vMainUV2\r\n    #else\r\n        varying vec2 vEmissiveUV;\r\n    #endif\r\n    uniform sampler2D emissiveSampler;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n     uniform float alphaCutOff;\r\n#endif\r\n\r\n#ifdef SHADE\r\n    uniform sampler2D shadeSampler;\r\n    #if SHADEDIRECTUV == 1\r\n        #define vShadeUV vMainUV1\r\n    #elif SHADEDIRECTUV == 2\r\n        #define vShadeUV vMainUV2\r\n    #else\r\n        varying vec2 vShadeUV;\r\n    #endif\r\n#endif\r\n#ifdef RECEIVE_SHADOW\r\n    uniform sampler2D receiveShadowSampler;\r\n    #if RECEIVE_SHADOWDIRECTUV == 1\r\n        #define vReceiveShadowUV vMainUV1\r\n    #elif RECEIVE_SHADOWDIRECTUV == 2\r\n        #define vReceiveShadowUV vMainUV2\r\n    #else\r\n        varying vec2 vReceiveShadowUV;\r\n    #endif\r\n#endif\r\n#ifdef SHADING_GRADE\r\n    uniform sampler2D shadingGradeSampler;\r\n    #if SHADING_GRADEDIRECTUV == 1\r\n        #define vShadingGradeUV vMainUV1\r\n    #elif SHADING_GRADEDIRECTUV == 2\r\n        #define vShadingGradeUV vMainUV2\r\n    #else\r\n        varying vec2 vShadingGradeUV;\r\n    #endif\r\n#endif\r\n#ifdef RIM\r\n    uniform sampler2D rimSampler;\r\n    #if RIMDIRECTUV == 1\r\n        #define vRimUV vMainUV1\r\n    #elif RIMDIRECTUV == 2\r\n        #define vRimUV vMainUV2\r\n    #else\r\n        varying vec2 vRimUV;\r\n    #endif\r\n#endif\r\n#ifdef MATCAP\r\n    uniform sampler2D matCapSampler;\r\n    #if MATCAPDIRECTUV == 1\r\n        #define vMatCapUV vMainUV1\r\n    #elif MATCAPDIRECTUV == 2\r\n        #define vMatCapUV vMainUV2\r\n    #else\r\n        varying vec2 vMatCapUV;\r\n    #endif\r\n#endif\r\n#ifdef OUTLINE_WIDTH\r\n    uniform sampler2D outlineWidthSampler;\r\n    #if OUTLINE_WIDTHDIRECTUV == 1\r\n        #define vOutlineWidthUV vMainUV1\r\n    #elif OUTLINE_WIDTHDIRECTUV == 2\r\n        #define vOutlineWidthUV vMainUV2\r\n    #else\r\n        varying vec2 vOutlineWidthUV;\r\n    #endif\r\n#endif\r\n\r\n/**\r\n* DirectionLight, PointLight の角度を計算\r\n*/\r\nvec3 computeLightDirection(vec4 lightData) {\r\n      return normalize(mix(lightData.xyz - vPositionW, -lightData.xyz, lightData.w));\r\n}\r\n\r\n/**\r\n* SpotLight の角度を計算\r\n*/\r\nvec3 computeSpotLightDirection(vec4 lightData) {\r\n     return normalize(lightData.xyz - vPositionW);\r\n}\r\n\r\n/**\r\n* HemisphericLight の角度を計算\r\n*/\r\nvec3 computeHemisphericLightDirection(vec4 lightData, vec3 vNormal) {\r\n     return normalize(lightData.xyz);\r\n}\r\n\r\n/**\r\n* MToon シェーダーの陰実装\r\n*/\r\nvec4 computeMToonDiffuseLighting(vec3 worldView, vec3 worldNormal, vec2 uvOffset, vec3 lightDirection, vec4 lightDiffuse, float shadow) {\r\n    float _receiveShadow = receiveShadowRate;\r\n#ifdef RECEIVE_SHADOW\r\n    _receiveShadow = _receiveShadow * texture2D(receiveShadowSampler, vReceiveShadowUV + uvOffset).a;\r\n#endif\r\n\r\n    float _shadingGrade = shadingGradeRate;\r\n#ifdef SHADING_GRADE\r\n    _shadingGrade = _shadingGrade * (1.0 - texture2D(shadingGradeSampler, vShadingGradeUV + uvOffset).r);\r\n#endif\r\n\r\n    // lighting intensity\r\n    float _lightIntensity = dot(lightDirection, worldNormal);\r\n    _lightIntensity = _lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]\r\n    _lightIntensity = _lightIntensity * (1.0 - _receiveShadow * (1.0 - (shadow * 0.5 + 0.5))); // receive shadow\r\n    _lightIntensity = _lightIntensity * _shadingGrade; // darker\r\n    _lightIntensity = _lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\r\n    _lightIntensity = smoothstep(shadeShift, shadeShift + (1.0 - shadeToony), _lightIntensity); // shade & tooned\r\n\r\n    // lighting with color\r\n    vec3 _directLighting = lightDiffuse.rgb; // direct\r\n    vec3 _lighting = _directLighting;\r\n    _lighting = mix(_lighting, vec3(max(0.001, max(_lighting.x, max(_lighting.y, _lighting.z)))), lightColorAttenuation);\r\n\r\n    // GI\r\n    vec3 _indirectLighting = indirectLightIntensity * vAmbientColor.rgb;\r\n    _indirectLighting = mix(_indirectLighting, vec3(max(0.001, max(_indirectLighting.x, max(_indirectLighting.y, _indirectLighting.z)))), lightColorAttenuation);\r\n\r\n    // color lerp\r\n    vec3 _shade = vShadeColor;\r\n#ifdef SHADE\r\n    _shade = _shade * texture2D(shadeSampler, vShadeUV + uvOffset).rgb;\r\n#endif\r\n\r\n    vec4 _lit = vDiffuseColor;\r\n#ifdef DIFFUSE\r\n    _lit = _lit * texture2D(diffuseSampler, vDiffuseUV + uvOffset);\r\n#endif\r\n\r\n    vec3 _result = mix(_shade.rgb, _lit.rgb, _lightIntensity);\r\n    _result = _result * _lighting + _indirectLighting * _lit.rgb;\r\n\r\n    // pure light\r\n    vec3 _pureLight = _lighting * _lightIntensity * _indirectLighting;\r\n    _pureLight = mix(_pureLight, vec3(max(_pureLight.x, max(_pureLight.y, _pureLight.z))), lightColorAttenuation);\r\n\r\n    // parametric rim lighting\r\n#ifdef MTOON_FORWARD_ADD\r\n#else\r\n    vec3 _rimColor = vRimColor.rgb;\r\n#ifdef RIM\r\n    _rimColor = _rimColor * texture2D(rimSampler, vRimUV + uvoffset).rgb;\r\n#endif\r\n    vec3 _rim = pow(clamp(1.0 - dot(worldNormal, worldView) + rimLift, 0.0, 1.0), rimFresnelPower) * _rimColor.rgb;\r\n    _rim *= mix(vec3(1.0), _pureLight, rimLightingMix);\r\n    _result += _rim;\r\n#endif\r\n\r\n    // additive matcap\r\n#ifdef MTOON_FORWARD_ADD\r\n#else\r\n#ifdef MATCAP\r\n    vec3 _worldViewUp = normalize(vEyeUp - worldView * dot(worldView, vEyeUp));\r\n    vec3 _worldViewRight = normalize(cross(worldView, _worldViewUp));\r\n    vec2 _matCapUv = vec2(dot(_worldViewRight, worldNormal), dot(_worldViewUp, worldNormal)) * 0.5 + 0.5;\r\n    _matCapUv.y = (1.0 - _matCapUv.y);\r\n    vec3 _matCapLighting = texture2D(matCapSampler, _matCapUv + uvOffset).rgb;\r\n    _result += _matCapLighting;\r\n#endif\r\n#endif\r\n\r\n#ifdef MTOON_OUTLINE_COLOR_FIXED\r\n    _result = mix(_result, vOutlineColor.rgb, isOutline);\r\n#elif defined(MTOON_OUTLINE_COLOR_MIXED)\r\n    _result = mix(_result, vOutlineColor.rgb * mix(vec3(1.0), _result, outlineLightingMix), isOutline);\r\n#else\r\n#endif\r\n\r\n    // debug\r\n#ifdef MTOON_DEBUG_NORMAL\r\n    #ifdef MTOON_FORWARD_ADD\r\n        return vec4(0.0);\r\n    #else\r\n        return vec4(worldNormal * 0.5 + 0.5, _lit.a);\r\n    #endif\r\n#elif defined(MTOON_DEBUG_LITSHADERATE)\r\n    #ifdef MTOON_FORWARD_ADD\r\n        return vec4(0.0);\r\n    #else\r\n        return vec4(_lightIntensity * _lighting, _lit.a);\r\n    #endif\r\n#endif\r\n\r\n    return vec4(_result, _lit.a * vOutlineColor.a);\r\n}\r\n\r\n#include<bumpFragmentFunctions>\r\n#include<clipPlaneFragmentDeclaration>\r\n#include<logDepthDeclaration>\r\n#include<fogFragmentDeclaration>\r\n\r\nvoid main(void) {\r\n#ifdef MTOON_CLIP_IF_OUTLINE_IS_NONE\r\n    #ifdef MTOON_OUTLINE_WIDTH_WORLD\r\n    #elif MTOON_OUTLINE_WIDTH_SCREEN\r\n    #else\r\n        discard;\r\n    #endif\r\n#endif\r\n\r\n#include<clipPlaneFragment>\r\n\r\n    vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\r\n\r\n    // Base color\r\n    vec4 baseColor = vec4(1., 1., 1., 1.);\r\n    vec3 diffuseColor = vDiffuseColor.rgb;\r\n\r\n\r\n#ifdef DIFFUSE\r\n    baseColor.rgb *= vDiffuseInfos.y;\r\n#endif\r\n\r\n    // Alpha\r\n    float alpha = 1.0;\r\n\r\n    // Bump\r\n#ifdef NORMAL\r\n     vec3 normalW = normalize(vNormalW);\r\n#else\r\n     vec3 normalW = normalize(-cross(dFdx(vPositionW), dFdy(vPositionW)));\r\n#endif\r\n\r\n#include<bumpFragment>\r\n\r\n#ifdef TWOSIDEDLIGHTING\r\n     normalW = gl_FrontFacing ? normalW : -normalW;\r\n#endif\r\n\r\n#include<depthPrePass>\r\n\r\n    // Ambient color\r\n    vec3 baseAmbientColor = vec3(1., 1., 1.);\r\n    float glossiness = 0.;\r\n\r\n    // Lighting\r\n    vec3 diffuseBase = vec3(0., 0., 0.);\r\n    lightingInfo info;\r\n    float shadow = 1.;\r\n    vec3 lightDirection = vec3(0.0, 1.0, 0.0);\r\n    vec4 mtoonDiffuse = vec4(0.0, 0.0, 0.0, 1.0);\r\n\r\n// 通常の lightFragment ではなく、自前実装の mtoonLightFragment を読み込む\r\n#include<mtoonLightFragment>[0..maxSimultaneousLights]\r\n\r\n    // Emissive\r\n    vec3 emissiveColor = vEmissiveColor.rgb;\r\n#ifdef EMISSIVE\r\n     emissiveColor *= texture2D(emissiveSampler, vEmissiveUV + uvOffset).rgb * vEmissiveInfos.y;\r\n#endif\r\n\r\n    vec3 finalDiffuse = clamp(diffuseBase + emissiveColor, 0.0, 1.0) * baseColor.rgb;\r\n\r\n    // Composition\r\n    vec4 color = vec4(finalDiffuse, alpha);\r\n\r\n    color.rgb = max(color.rgb, 0.);\r\n#include<logDepthFragment>\r\n#include<fogFragment>\r\n\r\n     color.a *= visibility;\r\n\r\n#ifdef PREMULTIPLYALPHA\r\n    // Convert to associative (premultiplied) format if needed.\r\n    color.rgb *= color.a;\r\n#endif\r\n\r\n     gl_FragColor = color;\r\n}\r\n"},function(e,r,i){"use strict";i.r(r);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var n=function(e,r){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,r){e.__proto__=r}||function(e,r){for(var i in r)r.hasOwnProperty(i)&&(e[i]=r[i])})(e,r)};function t(e,r){function i(){this.constructor=e}n(e,r),e.prototype=null===r?Object.create(r):(i.prototype=r.prototype,new i)}function o(e,r,i,n){var t,o=arguments.length,a=o<3?r:null===n?n=Object.getOwnPropertyDescriptor(r,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,r,i,n);else for(var s=e.length-1;s>=0;s--)(t=e[s])&&(a=(o<3?t(a):o>3?t(r,i,a):t(r,i))||a);return o>3&&a&&Object.defineProperty(r,i,a),a}var a=i(7),s=i(3),l=i(5),d=i(2),f=i(9),u=i(4),h=i(6),c=i(0),p=i(10),m=function(e){function r(){var r=e.call(this)||this;return r.MTOON_OUTLINE_WIDTH_WORLD=!1,r.MTOON_OUTLINE_WIDTH_SCREEN=!1,r.MTOON_OUTLINE_COLOR_FIXED=!1,r.MTOON_OUTLINE_COLOR_MIXED=!1,r.MTOON_DEBUG_NORMAL=!1,r.MTOON_DEBUG_LITSHADERRATE=!1,r.NORMAL=!1,r.TANGENT=!1,r.UV1=!1,r.UV2=!1,r.VERTEXALPHA=!1,r.MAINUV1=!1,r.MAINUV2=!1,r.DIFFUSE=!1,r.DIFFUSEDIRECTUV=0,r.EMISSIVE=!1,r.EMISSIVEDIRECTUV=0,r.BUMP=!1,r.BUMPDIRECTUV=0,r.SHADE=!1,r.SHADEDIRECTUV=0,r.RECEIVE_SHADOW=!1,r.RECEIVE_SHADOWDIRECTUV=0,r.SHADING_GRADE=!1,r.SHADING_GRADEDIRECTUV=0,r.RIM=!1,r.RIMDIRECTUV=0,r.MATCAP=!1,r.MATCAPDIRECTUV=0,r.OUTLINE_WIDTH=!1,r.OUTLINE_WIDTHDIRECTUV=0,r.MULTIVIEW=!1,r.FOG=!1,r.POINTSIZE=!1,r.LOGARITHMICDEPTH=!1,r.NONUNIFORMSCALING=!1,r.ALPHATEST=!1,r.DEPTHPREPASS=!1,r.NUM_MORPH_INFLUENCERS=0,r.NUM_BONE_INFLUENCERS=0,r.BonesPerMesh=0,r.TWOSIDEDLIGHTING=!1,r.CLIPPLANE=!1,r.CLIPPLANE2=!1,r.CLIPPLANE3=!1,r.CLIPPLANE4=!1,r.BONETEXTURE=!1,r.INSTANCES=!1,r.SHADOWFLOAT=!1,r.MORPHTARGETS=!1,r.MORPHTARGETS_NORMAL=!1,r.MORPHTARGETS_TANGENT=!1,r.PREMULTIPLYALPHA=!1,r.rebuild(),r}return t(r,e),r}(i(11).MaterialDefines),v=i(8),g="MToonOutline",_=function(){function e(r,i){this.scene=r,this.material=i,this._savedDepthWrite=!1,this.name=g+"_"+i.name+"_"+e.rendererId++,this.scene._addComponent(this),this._engine=this.scene.getEngine()}return e.prototype.register=function(){this.scene._beforeRenderingMeshStage.registerStep(v.SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE,this,this._beforeRenderingMesh),this.scene._afterRenderingMeshStage.registerStep(v.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)},e.prototype.rebuild=function(){},e.prototype.dispose=function(){delete this.scene,delete this.material,delete this._engine},e.prototype.render=function(e,r,i){var n=r.effect;n&&n.isReady()&&(this.material.applyOutlineCullMode(),this._engine.enableEffect(n),e._bind(r,n,l.Material.TriangleFillMode),this._engine.setZOffset(-1),e._processRendering(r,n,l.Material.TriangleFillMode,i,this.isHardwareInstancedRendering(r._id,i),function(i,t,o){o.bindForSubMesh(t,e,r),n.setMatrix("world",t),n.setFloat("isOutline",1)},this.material),this._engine.setZOffset(0),this.material.restoreOutlineCullMode())},e.prototype._beforeRenderingMesh=function(e,r,i){this._savedDepthWrite=this._engine.getDepthWrite(),this.willRender(r)&&(this._engine.setDepthWrite(!1),this.render(r.getRenderingMesh(),r,i),this._engine.setDepthWrite(this._savedDepthWrite))},e.prototype._afterRenderingMesh=function(e,r,i){this.willRender(r)&&this._savedDepthWrite&&(this._engine.setDepthWrite(!0),this._engine.setColorWrite(!1),this.render(r.getRenderingMesh(),r,i),this._engine.setColorWrite(!0))},e.prototype.isHardwareInstancedRendering=function(e,r){return this._engine.getCaps().instancedArrays&&null!==r.visibleInstances[e]&&void 0!==r.visibleInstances[e]},e.prototype.willRender=function(e){var r=e.getMaterial();return!(!r||"MToonMaterial"!==r.getClassName()||r.getOutlineRendererName()!==this.name)},e.rendererId=0,e}(),M=(i(12),i(13),i(1));var b,S,T,I,y=i(14).default,x=i(15).default,D=i(16).default,O=i(17).default,E=i(18).default,C=i(19).default;!function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate"}(b||(b={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(S||(S={})),function(e){e[e.None=0]="None",e[e.WorldCorrdinates=1]="WorldCorrdinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}(T||(T={})),function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}(I||(I={}));var U=function(e){function r(r,i){var n,t=e.call(this,r,i)||this;return t._diffuseTexture=null,t.diffuseTexture=null,t._emissiveTexture=null,t.emissiveTexture=null,t._bumpTexture=null,t.bumpTexture=null,t._shadeTexture=null,t.shadeTexture=null,t._receiveShadowTexture=null,t.receiveShadowTexture=null,t._shadingGradeTexture=null,t.shadingGradeTexture=null,t._rimTexture=null,t.rimTexture=null,t._matCapTexture=null,t.matCapTexture=null,t._outlineWidthTexture=null,t.outlineWidthTexture=null,t.maxSimultaneousLights=1,t.specularSupported=!1,t.useVertexColor=!1,t.useBones=!0,t.useMorphTargets=!0,t.useVertexAlpha=!1,t._useLogarithmicDepth=!1,t._disableLighting=!1,t.disableLighting=!1,t._twoSidedLighting=!1,t.twoSidedLighting=!1,t._alphaCutOff=.5,t.alphaCutOff=.5,t.diffuseColor=new u.Color3(1,1,1),t.ambientColor=new u.Color3(.1,.1,.1),t.globalAmbientColor=new u.Color3(0,0,0),t.emissiveColor=new u.Color3(0,0,0),t.shadeColor=new u.Color3(.97,.81,.86),t.rimColor=new u.Color3(0,0,0),t.outlineColor=new u.Color3(0,0,0),t._bumpScale=1,t._receiveShadowRate=1,t._shadingGradeRate=1,t._shadeShift=0,t._shadeToony=.9,t._lightColorAttenuation=0,t._indirectLightIntensity=.1,t._rimLightingMix=0,t._rimFresnelPower=1,t._rimLift=0,t._outlineWidth=.5,t._outlineScaledMaxDistance=1,t._outlineLightingMix=1,t._alphaTest=!1,t.alphaTest=!1,t._alphaBlend=!1,t._debugMode=b.None,t.debugMode=b.None,t._outlineWidthMode=T.None,t.outlineColorMode=S.MixedLighting,t._cullMode=I.Back,t._outlineCullMode=I.Front,t.outlineCullMode=I.Front,t.storedCullMode=I.Back,s.Effect.IncludesShadersStore.mtoonUboDeclaration||(s.Effect.IncludesShadersStore.mtoonUboDeclaration=y,s.Effect.IncludesShadersStore.mtoonVertexDeclaration=x,s.Effect.IncludesShadersStore.mtoonFragmentDeclaration=D,s.Effect.IncludesShadersStore.mtoonLightFragment=O,s.Effect.ShadersStore.mtoonVertexShader=E,s.Effect.ShadersStore.mtoonFragmentShader=C),t.inspectableCustomProperties=t.inspectableCustomProperties||[],(n=t.inspectableCustomProperties).push.apply(n,[{label:"DiffuseColor",propertyName:"diffuseColor",type:M.InspectableType.Color3},{label:"AmbientColor",propertyName:"ambientColor",type:M.InspectableType.Color3},{label:"EmissiveColor",propertyName:"emissiveColor",type:M.InspectableType.Color3},{label:"ShadeColor",propertyName:"shadeColor",type:M.InspectableType.Color3},{label:"RimColor",propertyName:"rimColor",type:M.InspectableType.Color3},{label:"OutlineColor",propertyName:"outlineColor",type:M.InspectableType.Color3},{label:"ReceiveShadowRate",propertyName:"receiveShadowRate",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadingGradeRate",propertyName:"shadingGradeRate",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadeShift",propertyName:"shadeShift",type:M.InspectableType.Slider,min:-1,max:1,step:.01},{label:"ShadeToony",propertyName:"shadeToony",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"LightColorAttenuation",propertyName:"lightColorAttenuation",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"IndirectLightIntensity",propertyName:"indirectLightIntensity",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimLightingMix",propertyName:"rimLightingMix",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimFresnelPower",propertyName:"rimFresnelPower",type:M.InspectableType.Slider,min:.01,max:100,step:4},{label:"RimLift",propertyName:"rimLift",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"OutlineWidth",propertyName:"outlineWidth",type:M.InspectableType.Slider,min:.01,max:1,step:.01},{label:"OutlineScaledMaxDistance",propertyName:"outlineScaledMaxDistance",type:M.InspectableType.Slider,min:1,max:10,step:.01},{label:"OutlineLightingMix",propertyName:"outlineLightingMix",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"DebugMode",propertyName:"debugMode",type:M.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineWidthMode",propertyName:"outlineWidthMode",type:M.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineColorMode",propertyName:"outlineColorMode",type:M.InspectableType.Slider,min:0,max:1,step:1},{label:"CullMode",propertyName:"cullMode",type:M.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineCullMode",propertyName:"outlineCullMode",type:M.InspectableType.Slider,min:0,max:2,step:1},{label:"AlphaCutOff",propertyName:"alphaCutOff",type:M.InspectableType.Slider,min:0,max:1,step:.01}]),t}return t(r,e),Object.defineProperty(r.prototype,"appendedTextures",{get:function(){return[this._diffuseTexture,this._emissiveTexture,this._bumpTexture,this._shadeTexture,this._receiveShadowTexture,this._shadingGradeTexture,this._matCapTexture,this._outlineWidthTexture]},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"appendedActiveTextures",{get:function(){return this.appendedTextures.filter(function(e){return null!==e})},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"useLogarithmicDepth",{get:function(){return this._useLogarithmicDepth},set:function(e){var r=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported;this._useLogarithmicDepth!==r&&(this._useLogarithmicDepth=r,this._markAllSubMeshesAsMiscDirty())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"bumpScale",{get:function(){return this._bumpScale},set:function(e){this._bumpScale=e},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"receiveShadowRate",{get:function(){return this._receiveShadowRate},set:function(e){this._receiveShadowRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"shadingGradeRate",{get:function(){return this._shadingGradeRate},set:function(e){this._shadingGradeRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"shadeShift",{get:function(){return this._shadeShift},set:function(e){this._shadeShift=Math.max(-1,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"shadeToony",{get:function(){return this._shadeToony},set:function(e){this._shadeToony=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"lightColorAttenuation",{get:function(){return this._lightColorAttenuation},set:function(e){this._lightColorAttenuation=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"indirectLightIntensity",{get:function(){return this._indirectLightIntensity},set:function(e){this._indirectLightIntensity=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"rimLightingMix",{get:function(){return this._rimLightingMix},set:function(e){this._rimLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"rimFresnelPower",{get:function(){return this._rimFresnelPower},set:function(e){this._rimFresnelPower=Math.max(0,Math.min(100,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"rimLift",{get:function(){return this._rimLift},set:function(e){this._rimLift=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineWidth",{get:function(){return this._outlineWidth},set:function(e){this._outlineWidth=Math.max(.01,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineScaledMaxDistance",{get:function(){return this._outlineScaledMaxDistance},set:function(e){this._outlineScaledMaxDistance=Math.max(1,Math.min(10,e)),this._markAllSubMeshesAsAttributesDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineLightingMix",{get:function(){return this._outlineLightingMix},set:function(e){this._outlineLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"alphaBlend",{get:function(){return this._alphaBlend},set:function(e){this._alphaBlend=e,e&&(this.backFaceCulling=!0),this._markAllSubMeshesAsMiscDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"outlineWidthMode",{get:function(){return this._outlineWidthMode},set:function(e){this._outlineWidthMode=e,e===T.None||this.outlineRenderer||(this.outlineRenderer=new _(this.getScene(),this)),this._markAllSubMeshesAsMiscDirty()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"cullMode",{get:function(){return this._cullMode},set:function(e){switch(this._cullMode=e,this._cullMode){case I.Off:this.backFaceCulling=!1,this.sideOrientation=l.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1;break;case I.Front:this.backFaceCulling=!0,this.sideOrientation=l.Material.CounterClockWiseSideOrientation,this.twoSidedLighting=!0;break;case I.Back:this.backFaceCulling=!0,this.sideOrientation=l.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1}this._markAllSubMeshesAsMiscDirty()},enumerable:!0,configurable:!0}),r.prototype.applyOutlineCullMode=function(){this.storedCullMode=this.cullMode,this.cullMode=this._outlineCullMode},r.prototype.restoreOutlineCullMode=function(){this.cullMode=this.storedCullMode},r.prototype.getOutlineRendererName=function(){return this.outlineRenderer?this.outlineRenderer.name:""},r.prototype.isReadyForSubMesh=function(e,r,i){if(void 0===i&&(i=!1),r.effect&&this.isFrozen&&this._wasPreviouslyReady)return!0;r._materialDefines||(r._materialDefines=new m);var n=this.getScene(),t=r._materialDefines;if(!this.checkReadyOnEveryCall&&r.effect&&t._renderId===n.getRenderId())return!0;var o=n.getEngine();if(t._needNormals=d.MaterialHelper.PrepareDefinesForLights(n,e,t,this.specularSupported,this.maxSimultaneousLights,this._disableLighting),this.outlineWidthMode!==T.None&&(t._needNormals=!0),this.applyDefines(t),d.MaterialHelper.PrepareDefinesForMultiview(n,t),t._areTexturesDirty){if(t._needUVs=!1,t.MAINUV1=!1,t.MAINUV2=!1,n.texturesEnabled){if(!(this.isReadyForTexture(this._diffuseTexture,t,"DIFFUSE")&&this.isReadyForTexture(this._emissiveTexture,t,"EMISSIVE")&&this.isReadyForTexture(this._shadeTexture,t,"SHADE")&&this.isReadyForTexture(this._receiveShadowTexture,t,"RECEIVE_SHADOW")&&this.isReadyForTexture(this._shadingGradeTexture,t,"SHADING_GRADE")&&this.isReadyForTexture(this._rimTexture,t,"RIM")&&this.isReadyForTexture(this._matCapTexture,t,"MATCAP")&&this.isReadyForTexture(this._outlineWidthTexture,t,"OUTLINE_WIDTH")))return!1;if(n.getEngine().getCaps().standardDerivatives&&this._bumpTexture){if(!this._bumpTexture.isReady())return!1;d.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture,t,"BUMP")}else t.BUMP=!1;t.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else t.DIFFUSE=!1,t.EMISSIVE=!1,t.SHADE=!1,t.RECEIVE_SHADOW=!1,t.SHADING_GRADE=!1,t.RIM=!1,t.MATCAP=!1,t.OUTLINE_WIDTH=!1,t.BUMP=!1;t.PREMULTIPLYALPHA=this.alphaMode===a.Constants.ALPHA_PREMULTIPLIED||this.alphaMode===a.Constants.ALPHA_PREMULTIPLIED_PORTERDUFF}if(d.MaterialHelper.PrepareDefinesForMisc(e,n,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(e),t),d.MaterialHelper.PrepareDefinesForAttributes(e,t,this.useVertexColor,this.useBones,this.useMorphTargets,this.useVertexAlpha),d.MaterialHelper.PrepareDefinesForFrameBoundValues(n,o,t,i),t.isDirty){t.markAsProcessed();var l=new s.EffectFallbacks;t.BUMP&&l.addFallback(0,"BUMP"),t.FOG&&l.addFallback(1,"FOG"),t.POINTSIZE&&l.addFallback(0,"POINTSIZE"),t.LOGARITHMICDEPTH&&l.addFallback(0,"LOGARITHMICDEPTH"),d.MaterialHelper.HandleFallbacksForShadows(t,l,this.maxSimultaneousLights),t.MULTIVIEW&&l.addFallback(0,"MULTIVIEW");var f=[h.VertexBuffer.PositionKind];t.NORMAL&&f.push(h.VertexBuffer.NormalKind),t.TANGENT&&f.push(h.VertexBuffer.TangentKind),t.UV1&&f.push(h.VertexBuffer.UVKind),t.UV2&&f.push(h.VertexBuffer.UV2Kind),d.MaterialHelper.PrepareAttributesForBones(f,e,t,l),d.MaterialHelper.PrepareAttributesForInstances(f,t),d.MaterialHelper.PrepareAttributesForMorphTargets(f,e,t);var u=["world","view","viewProjection","vLightsType","visibility","mBones","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vFogInfos","vFogColor","pointSize","alphaCutOff","logarithmicDepthConstant","vTangentSpaceParams","boneTextureWidth","vDiffuseColor","vDiffuseInfos","diffuseMatrix","vEmissiveColor","vEmissiveInfos","emissiveMatrix","vBumpInfos","bumpMatrix","vShadeColor","vShadeInfos","shadeMatrix","vReceiveShadowInfos","receiveShadowMatrix","vShadingGradeInfos","shadingGradeMatrix","vRimColor","vRimInfos","RimMatrix","vMatCapInfos","MatCapMatrix","vOutlineColor","vOutlineWidthInfos","outlineWidthMatrix","aspect","isOutline","shadingGradeRate","receiveShadowRate","shadeShift","shadeToony","rimLightingMix","rimFresnelPower","rimLift","lightColorAttenuation","indirectLightIntensity","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","vEyePosition","vEyeUp"],c=["diffuseSampler","emissiveSampler","bumpSampler","boneSampler","shadeSampler","receiveShadowSampler","shadingGradeSampler","rimSampler","matCapSampler","outlineWidthSampler"],p=["Material","Scene"];d.MaterialHelper.PrepareUniformsAndSamplersList({uniformsNames:u,uniformBuffersNames:p,samplers:c,defines:t,maxSimultaneousLights:this.maxSimultaneousLights}),this.applyDefines(t);var v=t.toString(),g=r.effect,_=n.getEngine().createEffect("mtoon",{attributes:f,uniformsNames:u,uniformBuffersNames:p,samplers:c,defines:v,fallbacks:l,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this.maxSimultaneousLights,maxSimultaneousMorphTargets:t.NUM_MORPH_INFLUENCERS}},o);_&&(this.allowShaderHotSwapping&&g&&!_.isReady()?(_=g,t.markAsUnprocessed()):(n.resetCachedMaterial(),r.setEffect(_,t),this.buildUniformLayout()))}return!(!r.effect||!r.effect.isReady())&&(t._renderId=n.getRenderId(),this._wasPreviouslyReady=!0,!0)},r.prototype.bindForSubMesh=function(e,r,i){var n=this.getScene(),t=i._materialDefines,o=i.effect;if(t&&o){this._activeEffect=o,this.bindOnlyWorldMatrix(e),d.MaterialHelper.BindBonesParameters(r,o);var a=n.isCachedMaterialInvalid(this,o,r.visibility);if(a){if(this._uniformBuffer.bindToEffect(o,"Material"),this.bindViewProjection(o),(!this._uniformBuffer.useUbo||!this.isFrozen||!this._uniformBuffer.isSync)&&n.texturesEnabled){if(this.bindTexture(this._diffuseTexture,o,"diffuse","vDiffuseInfos"),o.setFloat("alphaCutOff",this._alphaCutOff),this.bindTexture(this._emissiveTexture,o,"emissive","vEmissiveInfos"),this._bumpTexture){this._uniformBuffer.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this._bumpScale);var s=this._bumpTexture.getTextureMatrix();s.isIdentityAs3x2()||this._uniformBuffer.updateMatrix("bumpMatrix",s),o.setTexture("bumpSampler",this._bumpTexture),n._mirroredCameraPosition?this._uniformBuffer.updateFloat2("vTangentSpaceParams",1,1):this._uniformBuffer.updateFloat2("vTangentSpaceParams",-1,-1)}this.bindTexture(this._shadeTexture,o,"shade","vShadeInfos"),this.bindTexture(this._receiveShadowTexture,o,"receiveShadow","vReceiveShadowInfos"),this.bindTexture(this._shadingGradeTexture,o,"shadingGrade","vShadingGradeInfos"),this.bindTexture(this._rimTexture,o,"rim","vRimInfos"),this.bindTexture(this._matCapTexture,o,"matCap","vMatCapInfos"),this.bindTexture(this._outlineWidthTexture,o,"outlineWidth","vOutlineWidthInfos")}this.pointsCloud&&this._uniformBuffer.updateFloat("pointSize",this.pointSize),this._uniformBuffer.updateFloat("visibility",r.visibility),this._uniformBuffer.updateFloat("receiveShadowRate",this._receiveShadowRate),this._uniformBuffer.updateFloat("shadingGradeRate",this._shadingGradeRate),this._uniformBuffer.updateFloat("shadeShift",this._shadeShift),this._uniformBuffer.updateFloat("shadeToony",this._shadeToony),this._uniformBuffer.updateFloat("lightColorAttenuation",this._lightColorAttenuation),this._uniformBuffer.updateFloat("indirectLightIntensity",this._indirectLightIntensity),this._uniformBuffer.updateFloat("rimLightingMix",this._rimLightingMix),this._uniformBuffer.updateFloat("rimFresnelPower",this._rimFresnelPower),this._uniformBuffer.updateFloat("rimLift",this._rimLift),this._uniformBuffer.updateFloat("outlineWidth",this._outlineWidth),this._uniformBuffer.updateFloat("outlineScaledMaxDistance",this._outlineScaledMaxDistance),this._uniformBuffer.updateFloat("outlineLightingMix",this._outlineLightingMix),d.MaterialHelper.BindClipPlane(o,n),n.ambientColor.multiplyToRef(this.ambientColor,this.globalAmbientColor),o.setColor3("vAmbientColor",this.globalAmbientColor),this._uniformBuffer.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),this._uniformBuffer.updateColor3("vEmissiveColor",this.emissiveColor),this._uniformBuffer.updateColor3("vShadeColor",this.shadeColor),this._uniformBuffer.updateColor3("vRimColor",this.rimColor),this._uniformBuffer.updateColor4("vOutlineColor",this.outlineColor,1),d.MaterialHelper.BindEyePosition(o,n),o.setVector3("vEyeUp",n.activeCamera.upVector)}!a&&this.isFrozen||(n.lightsEnabled&&!this.disableLighting&&d.MaterialHelper.BindLights(n,r,o,t,this.maxSimultaneousLights),n.fogEnabled&&r.applyFog&&n.fogMode!==p.Scene.FOGMODE_NONE&&this.bindView(o),d.MaterialHelper.BindFogParameters(n,r,o),t.NUM_MORPH_INFLUENCERS&&d.MaterialHelper.BindMorphTargetParameters(r,o),d.MaterialHelper.BindLogDepth(t,o,n)),o.setFloat("aspect",n.getEngine().getAspectRatio(n.activeCamera)),o.setFloat("isOutline",0),this._uniformBuffer.update(),this._afterBind(r,this._activeEffect)}},r.prototype.getAnimatables=function(){for(var e=[],r=0,i=this.appendedActiveTextures;r<i.length;r++){var n=i[r];n.animations&&n.animations.length>0&&e.push(n)}return e},r.prototype.getActiveTextures=function(){return e.prototype.getActiveTextures.call(this).concat(this.appendedActiveTextures)},r.prototype.hasTexture=function(r){return!!e.prototype.hasTexture.call(this,r)||this.appendedActiveTextures.length>0},r.prototype.dispose=function(r,i,n){if(delete this.outlineRenderer,i)for(var t=0,o=this.appendedActiveTextures;t<o.length;t++){o[t].dispose()}e.prototype.dispose.call(this,r,i,n)},r.prototype.buildUniformLayout=function(){this._uniformBuffer.addUniform("vDiffuseColor",4),this._uniformBuffer.addUniform("vDiffuseInfos",2),this._uniformBuffer.addUniform("diffuseMatrix",16),this._uniformBuffer.addUniform("vEmissiveColor",3),this._uniformBuffer.addUniform("vEmissiveInfos",2),this._uniformBuffer.addUniform("emissiveMatrix",16),this._uniformBuffer.addUniform("vBumpInfos",3),this._uniformBuffer.addUniform("bumpMatrix",16),this._uniformBuffer.addUniform("vShadeColor",3),this._uniformBuffer.addUniform("vShadeInfos",2),this._uniformBuffer.addUniform("shadeMatrix",16),this._uniformBuffer.addUniform("vReceiveShadowInfos",2),this._uniformBuffer.addUniform("receiveShadowMatrix",16),this._uniformBuffer.addUniform("vShadingGradeInfos",2),this._uniformBuffer.addUniform("shadingGradeMatrix",16),this._uniformBuffer.addUniform("vRimColor",3),this._uniformBuffer.addUniform("vRimInfos",2),this._uniformBuffer.addUniform("rimMatrix",16),this._uniformBuffer.addUniform("vMatCapInfos",2),this._uniformBuffer.addUniform("matCapMatrix",16),this._uniformBuffer.addUniform("vOutlineColor",3),this._uniformBuffer.addUniform("vOutlineWidthInfos",2),this._uniformBuffer.addUniform("outlineWidthMatrix",16),this._uniformBuffer.addUniform("vTangentSpaceParams",2),this._uniformBuffer.addUniform("pointSize",1),this._uniformBuffer.addUniform("visibility",1),this._uniformBuffer.addUniform("shadingGradeRate",1),this._uniformBuffer.addUniform("receiveShadowRate",1),this._uniformBuffer.addUniform("shadeShift",1),this._uniformBuffer.addUniform("shadeToony",1),this._uniformBuffer.addUniform("lightColorAttenuation",1),this._uniformBuffer.addUniform("indirectLightIntensity",1),this._uniformBuffer.addUniform("rimLightingMix",1),this._uniformBuffer.addUniform("rimFresnelPower",1),this._uniformBuffer.addUniform("rimLift",1),this._uniformBuffer.addUniform("outlineWidth",1),this._uniformBuffer.addUniform("outlineScaledMaxDistance",1),this._uniformBuffer.addUniform("outlineLightingMix",1),this._uniformBuffer.create()},r.prototype.bindTexture=function(e,r,i,n){if(e){this._uniformBuffer.updateFloat2(n,e.coordinatesIndex,e.level);var t=e.getTextureMatrix();t.isIdentityAs3x2()||this._uniformBuffer.updateMatrix(i+"Matrix",t),r.setTexture(i+"Sampler",e)}},r.prototype.isReadyForTexture=function(e,r,i){return e?!!e.isReadyOrNotBlocking()&&(d.MaterialHelper.PrepareDefinesForMergedUV(e,r,i),!0):(r[i]=!1,!0)},r.prototype.applyDefines=function(e){switch(this._debugMode){case b.Normal:!0!==e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!0,e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed());break;case b.LitShadeRate:!0!==e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_NORMAL=!1,e.MTOON_DEBUG_LITSHADERATE=!0,e.markAsUnprocessed());break;case b.None:!0===e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!1,e.markAsUnprocessed()),!0===e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed())}switch(this.outlineWidthMode){case T.WorldCorrdinates:!0!==e.MTOON_OUTLINE_WIDTH_WORLD&&(e.MTOON_OUTLINE_WIDTH_WORLD=!0,e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.markAsUnprocessed());break;case T.ScreenCoordinates:!0!==e.MTOON_OUTLINE_WIDTH_SCREEN&&(e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.MTOON_OUTLINE_WIDTH_SCREEN=!0,e.markAsUnprocessed());break;case T.None:!1===e.MTOON_OUTLINE_WIDTH_SCREEN&&!1===e.MTOON_OUTLINE_WIDTH_WORLD||(e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.markAsUnprocessed())}switch(this.outlineColorMode){case S.FixedColor:!0!==e.MTOON_OUTLINE_COLOR_FIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!0,e.MTOON_OUTLINE_COLOR_MIXED=!1,e.markAsUnprocessed());break;case S.MixedLighting:!0!==e.MTOON_OUTLINE_COLOR_MIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!1,e.MTOON_OUTLINE_COLOR_MIXED=!0,e.markAsUnprocessed())}},r.prototype.getClassName=function(){return"MToonMaterial"},r.prototype.getAlphaTestTexture=function(){return this.diffuseTexture},r.prototype.needAlphaBlending=function(){return this._alphaBlend},r.prototype.needAlphaTesting=function(){return this._alphaTest},r.prototype.clone=function(e){var i=this,n=c.SerializationHelper.Clone(function(){return new r(e,i.getScene())},this);return n.name=e,n.id=e,n},r.prototype.serialize=function(){return c.SerializationHelper.Serialize(this)},r.Parse=function(e,i,n){return c.SerializationHelper.Parse(function(){return new r(e.name,i)},e,i,n)},o([Object(c.serializeAsTexture)("diffuseTexture")],r.prototype,"_diffuseTexture",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],r.prototype,"diffuseTexture",void 0),o([Object(c.serializeAsTexture)("emissiveTexture")],r.prototype,"_emissiveTexture",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"emissiveTexture",void 0),o([Object(c.serializeAsTexture)("bumpTexture")],r.prototype,"_bumpTexture",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"bumpTexture",void 0),o([Object(c.serializeAsTexture)("shadeTexture")],r.prototype,"_shadeTexture",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"shadeTexture",void 0),o([Object(c.serializeAsTexture)("receiveShadowTexture")],r.prototype,"_receiveShadowTexture",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"receiveShadowTexture",void 0),o([Object(c.serializeAsTexture)("shadingGradeTexture")],r.prototype,"_shadingGradeTexture",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"shadingGradeTexture",void 0),o([Object(c.serializeAsTexture)("rimTexture")],r.prototype,"_rimTexture",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"rimTexture",void 0),o([Object(c.serializeAsTexture)("matCapTexture")],r.prototype,"_matCapTexture",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"matCapTexture",void 0),o([Object(c.serializeAsTexture)("outlineWidthTexture")],r.prototype,"_outlineWidthTexture",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"outlineWidthTexture",void 0),o([Object(c.serialize)()],r.prototype,"useLogarithmicDepth",null),o([Object(c.serialize)("disableLighting")],r.prototype,"_disableLighting",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"disableLighting",void 0),o([Object(c.serialize)("twoSidedLighting")],r.prototype,"_twoSidedLighting",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],r.prototype,"twoSidedLighting",void 0),o([Object(c.serialize)("alphaCutOff")],r.prototype,"_alphaCutOff",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsLightsDirty")],r.prototype,"alphaCutOff",void 0),o([Object(c.serializeAsColor3)("diffuse")],r.prototype,"diffuseColor",void 0),o([Object(c.serialize)("ambient")],r.prototype,"ambientColor",void 0),o([Object(c.serialize)("emissive")],r.prototype,"emissiveColor",void 0),o([Object(c.serialize)("shade")],r.prototype,"shadeColor",void 0),o([Object(c.serialize)("rim")],r.prototype,"rimColor",void 0),o([Object(c.serialize)("outline")],r.prototype,"outlineColor",void 0),o([Object(c.serialize)()],r.prototype,"bumpScale",null),o([Object(c.serialize)()],r.prototype,"receiveShadowRate",null),o([Object(c.serialize)()],r.prototype,"shadingGradeRate",null),o([Object(c.serialize)()],r.prototype,"shadeShift",null),o([Object(c.serialize)()],r.prototype,"shadeToony",null),o([Object(c.serialize)()],r.prototype,"lightColorAttenuation",null),o([Object(c.serialize)()],r.prototype,"indirectLightIntensity",null),o([Object(c.serialize)()],r.prototype,"rimLightingMix",null),o([Object(c.serialize)()],r.prototype,"rimFresnelPower",null),o([Object(c.serialize)()],r.prototype,"rimLift",null),o([Object(c.serialize)()],r.prototype,"outlineWidth",null),o([Object(c.serialize)()],r.prototype,"outlineScaledMaxDistance",null),o([Object(c.serialize)()],r.prototype,"outlineLightingMix",null),o([Object(c.serialize)("alphaTest")],r.prototype,"_alphaTest",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"alphaTest",void 0),o([Object(c.serialize)()],r.prototype,"alphaBlend",null),o([Object(c.serialize)("debugMode")],r.prototype,"_debugMode",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"debugMode",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"outlineColorMode",void 0),o([Object(c.serialize)()],r.prototype,"cullMode",null),o([Object(c.serialize)()],r.prototype,"_outlineCullMode",void 0),o([Object(c.expandToProperty)("_markAllSubMeshesAsMiscDirty")],r.prototype,"outlineCullMode",void 0),r}(f.PushMaterial);i.d(r,"MToonMaterial",function(){return U})}])});